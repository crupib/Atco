' *************************************************************************************
'                    Code Generated by EZGUI Professional Visual Designer 5.0
'           Portions: Copyright Christopher R. Boss, 2003 to 2011 All Rights Reserved !
'              Registered EZGUI 5.0 users may use generated code Royalty Free !
' *************************************************************************************
'
' -----------------------------------------------------------------------------------------
'            WARNING !    Do Not Modify any code WITHIN Protected Sections !
' You can add code (Sub,Function,etc.) BEFORE any Protected Routine by using the following
' CODE TAGS:        '<<SAVE>>      '<<END>>            and the Designer will not remove it.
' -----------------------------------------------------------------------------------------
'

' ======================================
' [PROTECTED CODE]         Do NOT Edit !
' ======================================


'
#COMPILE EXE
#DIM ALL        '   This is helpful to prevent errors in coding
' --------------------
#INCLUDE "C:\ezgui50pro\includes\ezgui50.inc"                          ' EZGUI Include file for Declares
' --------------------
' *************************************************************************************


' *************************************************************************************
'                   Code Generator Defined Constants and Declares
' *************************************************************************************
DECLARE FUNCTION Main_Initialize(BYVAL VerNum&) AS LONG
DECLARE SUB OtherForm_Events(FormName$, CID&, CMsg&, CVal&, Cancel&)
DECLARE SUB OtherForm_Design(FormName$)
DECLARE FUNCTION PreProcess_Events(FormName$, CID&, CMsg&, CVal&, Cancel&) AS LONG
DECLARE SUB EZ_MAINFORM_Display(BYVAL FParent$)
DECLARE SUB EZ_MAINFORM_Design()
DECLARE SUB EZ_MAINFORM_ParseEvents(CID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_Events(CID&, CMsg&, CVal&, Cancel&)
' ------------------------------------------------


' ----------------------------------------------------------
%MAINFORM_FILEMENU                               = 9000
' ----------------------------------------------------------

' ----------------------------------------------------------
%MAINFORM_SETUPMENU                              = 9100
' ----------------------------------------------------------

' ----------------------------------------------------------
%MAINFORM_WINDOWITEM                             = 9200
' ----------------------------------------------------------
%MAINFORM_XLABEL             = 100
%MAINFORM_XLABEL1            = 105
%MAINFORM_XLABEL2            = 110
%MAINFORM_RPOS               = 115
%MAINFORM_YPOS               = 120
%MAINFORM_XPOS               = 125
%MAINFORM_SETXPOS            = 130
%MAINFORM_SETYPOS            = 135
%MAINFORM_SETRPOS            = 140
%MAINFORM_XMOTORON           = 145
%MAINFORM_YMOTORON           = 150
%MAINFORM_RMOTORON           = 155
%MAINFORM_LABEL1             = 160
%MAINFORM_LABEL2             = 165
%MAINFORM_LABEL3             = 170
%MAINFORM_HTRACKBAR1         = 175
%MAINFORM_LABEL4             = 180
%MAINFORM_JOGRATE            = 185
%MAINFORM_LABEL5             = 190
%MAINFORM_BUTTON4            = 195
%MAINFORM_BUTTON5            = 200
%MAINFORM_BUTTON6            = 205
%MAINFORM_BUTTON7            = 210
%MAINFORM_BUTTON8            = 215
%MAINFORM_BUTTON9            = 220
%MAINFORM_BUTTON10           = 225
%MAINFORM_BUTTON11           = 230
%MAINFORM_BUTTON12           = 235
%MAINFORM_BUTTON13           = 240
%MAINFORM_BUTTON14           = 245
%MAINFORM_BUTTON15           = 250
%MAINFORM_BUTTON16           = 255
%MAINFORM_BUTTON17           = 260
%MAINFORM_BUTTON18           = 265
%MAINFORM_BUTTON19           = 270
%MAINFORM_BUTTON20           = 275
%MAINFORM_BUTTON21           = 280
%MAINFORM_LOG                = 285
%MAINFORM_POLAR              = 290
%MAINFORM_CARTESIAN          = 295
%MAINFORM_LABEL6             = 300
%MAINFORM_LABEL7             = 305
%MAINFORM_YPLUS              = 310
%MAINFORM_XMINUS             = 315
%MAINFORM_XPLUS              = 320
%MAINFORM_YMINUS             = 325
%MAINFORM_CONTINUOUS         = 330
%MAINFORM_STEP               = 335
%MAINFORM_SETALL             = 340
%MAINFORM_ALLOFF             = 345
%MAINFORM_ALLON              = 350
%MAINFORM_GOAUTOSCAN         = 355
%MAINFORM_BLANK              = 360
%MAINFORM_STOPSCAN           = 365
%MAINFORM_JOGCANVAS          = 370
%MAINFORM_RPLUS              = 375
%MAINFORM_RMINUS             = 380
%MAINFORM_FRAME1             = 385
%MAINFORM_FRAME2             = 390
%MAINFORM_FRAME3             = 395
%MAINFORM_FRAME4             = 400
%MAINFORM_FRAME5             = 405

DECLARE SUB MAINFORM_RPOS_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_YPOS_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_XPOS_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_SETXPOS_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_SETYPOS_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_SETRPOS_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_XMOTORON_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_YMOTORON_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_RMOTORON_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_HTRACKBAR1_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_JOGRATE_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_BUTTON4_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_BUTTON5_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_BUTTON6_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_BUTTON7_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_BUTTON8_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_BUTTON9_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_BUTTON10_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_BUTTON11_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_BUTTON12_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_BUTTON13_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_BUTTON14_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_BUTTON15_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_BUTTON16_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_BUTTON17_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_BUTTON18_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_BUTTON19_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_BUTTON20_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_BUTTON21_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_LOG_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_YPLUS_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_XMINUS_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_XPLUS_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_YMINUS_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_SETALL_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_ALLOFF_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_ALLON_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_GOAUTOSCAN_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_BLANK_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_STOPSCAN_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_JOGCANVAS_Draw(BYVAL FMode&)
DECLARE SUB MAINFORM_RPLUS_Events(MyID&, CMsg&, CVal&, Cancel&)
DECLARE SUB MAINFORM_RMINUS_Events(MyID&, CMsg&, CVal&, Cancel&)



' *************************************************************************************
'                 Code Generator Defined Global Variables and Types
' *************************************************************************************



'    Note:     Do NOT change the names of the EZGUI Callback Procedures !

' --------------------
#INCLUDE "C:\ezgui50pro\includes\ezwmain50.inc"                          ' EZGUI Include file for WinMain
' --------------------



' *************************************************************************************
'                       User Defined Global Variables and Types
'         (Put code in CODE TAGS! to protect from deletion by Code Generator !)
' *************************************************************************************


'<<SAVE>>'

MACRO CONST = MACRO
'misc const values
    CONST TRUE = -1
    CONST FALSE = 0

'Key codes
    CONST KeyUP = 72
    CONST KeyDN = 80
    CONST KeyLft = 75
    CONST KeyRgt = 77
    CONST KeyBKSPC = 8
    CONST KeySPC = 32
    CONST KeyEnter = 13
    CONST KeyEsc = 27

'Serial Input-Output (SIO) error mode difinitions
    CONST DoNothing = &H0
    CONST ErrorBox = &H1
    CONST AbortCom = &H2
    CONST ExitProgram = &H3


'***************************************************************************
'****************  SERVO NMC specific definitions  *************************
'***************************************************************************

    CONST AllServos = &HFF ' group command address
    CONST LastServo = &H4 ' last Pic servo address location

'Module type definitions
    CONST PicServoID = &H0
    CONST PicIoID =    &H2
    CONST ArmIoID =    &H5

'Module addresses, in order, as setup in current system network, change as needed.
    CONST PicServo1 = 1  'Pic servo module address #1; setup for X1 Axis
    CONST PicServo2 = 2  'Pic servo module address #2; setup for X2 Axis (Z Axis for LMT 3D scanner) 5/30/15
    CONST PicServo3 = 3  'Pic servo module address #3; setup for Y Axis
    CONST PicServo4 = 4  'Pic servo module address #4; setup for AUX use, no motor attached
    CONST PicIo  =    5  'Pic IO module address    #5; setup for AUX IO
    CONST ArmIo  =    6  'Arm IO module address    #6; custom module for 3D to 2D translation


'PIC SERVO  Status byte bit codes
    CONST MoveDone =   &H1
    CONST CksumErr =   &H2
    CONST OverCurrent= &H4
    CONST PowerOn =    &H8
    CONST PosError =   &H10
    CONST Limit1 =     &H20
    CONST Limit2 =     &H40
    CONST HomeInProg = &H80

'PIC SERVO Auxiliary status byte bit codes
    CONST IndexPulse =  &H1
    CONST PositionWrap= &H2
    CONST ServoOn =     &H4
    CONST AccelDone =   &H8
    CONST Slew =        &H10
    CONST ServoOverrun= &H20
    CONST PathMode =    &H40
    'bit 7 not used

'PIC IO Status byte bit codes
    ' bit 0 not used
'   CONST CksumErr =  &H2  Common all modules
    '2-7 not used

'ARM IO Status byte bit codes
    CONST PathOverFlow =  &H1
'   CONST CksumErr =   &H2   Common all modules
    'bit 2-5 not used, clear to 0
    CONST EncMotionError= &H40
    CONST MtrFltOrEstop = &H80


'MiscMode bit definitions
    CONST AmpEnabled =      &H1
    CONST PWMSelected =     &H2
    CONST VelSelected =     &H4
    CONST PosSelected =     &H8
    CONST OnL1Selected =    &H10
    CONST OnL2Selected =    &H20
    CONST OnIndexSelected = &H40
    CONST OnPeSelected =    &H80
    CONST OnCeSelected =    &H100
    CONST HomeFlagMask =    &HFE0F

    CONST PosDir = 1
    CONST NegDir = 0



'*****************************************************************************
'                             COMMAND CODES
'*****************************************************************************

'CMD 0x00 PIC SERVO
'Reset Position: Bit definitions
    CONST SetPosCtrRel= &H1
    CONST SetPosCtr =   &H2
    'bits 2-7: unused, clear to 0

'CMD 0x00 PIC IO
'Set Direction: Bit definitions
    'data byte 1
    CONST DirBit0 = &H1  '0 = output, 1 = input
    CONST DirBit1 = &H2
    CONST DirBit2 = &H4
    CONST DirBit3 = &H8
    CONST DirBit4 = &H10
    CONST DirBit5 = &H20
    CONST DirBit6 = &H40
    CONST DirBit7 = &H80
    'data byte 2
    CONST DirBit9 = &H1
    CONST DirBit10= &H2
    CONST DirBit11= &H4
    CONST DirBit12= &H8
    'bits 4-7: Don't care

'CMD 0x00 ARM IO
'Set Encoders: Bit definitions
    CONST SetEncM1 = &H1
    CONST SetEncM2 = &H2
    CONST SetEncM3 = &H4
    CONST SetStpM1 = &H8
    CONST SetStpM2 = &H10
    CONST SetStpM3 = &H20
    CONST SetImgM1 = &H40
    CONST SetImgM2 = &H80

'CMD 0x01
'Common all modules Set Address: Bits N/A

'CMD 0x02 & 0x03 PIC SERVO
'Define Status: Bit definitions
    CONST SendPos =      &H1
    CONST SendAD =       &H2
    CONST SendVel =      &H4
    CONST SendAux =      &H8
    CONST SendHome =     &H10
    CONST SendID =       &H20    'Common MC definition
    CONST SendPosErr =   &H40
    CONST SendPathLeft = &H80    'Common MC definition

'CMD 0x02 & 0x03 PIC IO
'Define Status: Bit definitions
    CONST SendIO =      &H1
    CONST SendAD1 =     &H2
    CONST SendAD2 =     &H4
    CONST SendAD3 =     &H8
    CONST SendCtr =     &H10
'   CONST SendID =      &H20   'common all NMC modules
    CONST SendSyncIO =  &H40
    CONST SendSyncCtr = &H80

'CMD 0x02 & 0x03 ARM IO
'Define Status: Bit definitions
    CONST SendEnc123 =      &H1  'Send Encoder Counter 1,2 & 3
    CONST SendStp123 =      &H2  'Send Step Counter 1,2 & 3
    CONST SendImg12  =      &H4  'Send Img Step Counter 1 & 2
'   CONST Unused =          &H8
'   CONST Unused =          &H10
'   CONST SendID =          &H20 'Common MC definition
    CONST SendFaultStop =   &H40 '**** see below
'   CONST SendPathLeft =    &H80 'Common with PIC-Servo

   'Byte return bit definitions for SendFaultStop
    CONST Servo1Fault = &H1
    CONST Servo2Fault = &H2
    CONST Servo3Fault = &H4
    CONST EStopFault =  &H8
'   CONST Unused =      &H10
'   CONST Unused =      &H20
'   CONST Unused =      &H40
'   CONST Unused =      &H80

'CMD 0x04 PIC SERVO
'Load Trajectory: Bit definitions
    CONST LoadPos = &H1
    CONST LoadVel = &H2
    CONST LoadAcc = &H4
    CONST LoadPWM = &H8
    CONST PosMode = &H10
    CONST VelMode = &H20
    CONST RevDir =  &H40
    CONST StartNow= &H80

'CMD 0x04
'PIC IO Set PWM: Bits N/A
'ARM IO Not Used

'CMD 0x05
'PIC SERVO Start Motion: Bits N/A
'PIC IO Synch Output: Bits N/A
'ARM IO Start Motion: Bits N/A

'CMD 0x06 PIC SERVO Set Gain: Bits N/A

'CMD 0x06 PIC IO
'Set Output: Bit Definitions
   'data byte 1
    CONST OutBit0 = &H1  '1 = on, 0 = off
    CONST OutBit1 = &H2
    CONST OutBit2 = &H4
    CONST OutBit3 = &H8
    CONST OutBit4 = &H10
    CONST OutBit5 = &H20
    CONST OutBit6 = &H40
    CONST OutBit7 = &H80
    'data byte 2
    CONST OutBit9 = &H1
    CONST OutBit10= &H2
    CONST OutBit11= &H4
    CONST OutBit12= &H8
    'bits 4-7: Don't care

'CMD 0x06 ARM IO Not Used

'CMD 0x07 PIC SERVO
'Stop Motor: Bit Definitions
    CONST EnableAmp =  &H1
    CONST MotorOff =   &H2
    CONST StopAbrupt = &H4
    CONST StopSmooth = &H8
    CONST StopHere =   &H10
    'bits 5-7: Unused, clear to 0

'CMD 0x07 PIC IO
'Set Synch Output: Bit Definitions
    'See Set Output CMD 0x06

'CMD 0x07 ARM IO
'Stop Motion: Bit Definitions
    CONST ImgCtsOff =     &H1
    CONST ResetPath =     &H2
    CONST StopOutAbrupt = &H4
    CONST StopOutSmooth = &H8
    CONST DisableM1 =     &H10
    CONST DisableM2 =     &H20
    CONST DisableM3 =     &H40
    CONST DiableImg =     &H80

'CMD 0x08 PIC SERVO
'I/O Control: Bit Definitions
    'bits 0,1: Not used, clear to 0
    CONST LmtMtrOff =   &H4
    CONST LmtMtrStop =  &H8
    CONST Phase3ON =    &H10
    CONST AntiPhaseON = &H20
    CONST FastPathON =  &H40
    CONST StepDirON =   &H80

'CMD 0x08 PIC IO
'Set Timer Mode: Bit Definitions
    CONST CtrTmrON =   &H1
    CONST CtrModeON =  &H2
    'bits 2,3: Not used, don't care
    'combined bits 5,4
    CONST PreScaleX2 = &H10
    CONST PreScaleX4 = &H20
    CONST PreScaleX8 = &H30
    'bits 6,7: Not used, don't care

'CMD 0x08 ARM IO
'Set Encoder Error Level: Bit Definitions
    CONST SetErrorCtsEnc1 =   &H1
    CONST SetErrorCtsEnc2 =   &H2
    CONST SetErrorCtsEnc3 =   &H4
    CONST SetSmoothInterval = &H8
    'bits 4-7: Not used, don't care

'CMD 0x09 PIC SERVO
'Set Homing: Bit Definitions
    CONST HomeOnLimit1 = &H1
    CONST HomeOnLimit2 = &H2
    CONST OnHomeMtrOff = &H4
    CONST HomeOnIndex =  &H8
    CONST OnHomeStop =   &H10
    CONST OnHomeSmooth = &H10
    CONST HomeOnPosErr = &H40
    CONST HomeOnAmpLmt = &H80

'CMD 0x09
'PIC IO Not Used
'ARM IO Not Used

'CMD 0x0A Common all modules
'Set Baud: Bit Definitions
    CONST Baud230 = &H5
    CONST Baud115 = &HA
    CONST Baud57 =  &H15
    CONST Baud19 =  &H40
    CONST Baud9 =   &H7F

'CMD 0x0B
'PIC SERVO Clear Bits: Bit N/A
'PIC IO Not Used
'ARM IO  Clear Latched Status Bits: Bit N/A


'CMD 0x0C PIC SERVO Save As Home: Bit N/A
'CMD 0x0C PIC IO  Synch Input: Bit N/A

'CMD 0x0C ARM IO
'Send Step Counts to Image and Servo: Bit Definitions
    CONST StepsOutMtr1 = &H1
    CONST StepsOutMtr2 = &H2
    CONST StepsOutMtr3 = &H4
    CONST StepsOutImg1 = &H8
    CONST StepsOutImg2 = &H10
    'bits 5-7: Not used, don't care

'CMD 0x0D
'PIC SERVO Add Path Points: Bit N/A
'PIC IO Not Used
'ARM IO Add Path Points: Bit N/A

'CMD 0x0E
'Common all modules No Op: Bits N/A

'CMD 0x0F
'Common all modules Reset: Bits N/A


'CMD 3: Read Status : Status definition bits
'Same as CMD 2

'CMD 4: Unused

    CONST PWMMode = 0 'PWM added KJL




'*********************************************************************************
'                                GLOBAL VARIBLES
'*********************************************************************************

'File IO
    GLOBAL filenum AS INTEGER
    GLOBAL HdrVer AS STRING * 20

'Keypad Table
    GLOBAL KeyTable() AS STRING

'COM Port
    GLOBAL McuPortNum AS LONG    ' GLOBAL McuPortNum AS LONG comm port file#
    GLOBAL McuPortName AS STRING
    GLOBAL McuPortBaud AS LONG
    GLOBAL RecvSize AS LONG
    GLOBAL XmitSize AS LONG
    GLOBAL MemSize AS LONG

'Joystick to pwm conversion table
    GLOBAL LF() AS BYTE
    GLOBAL LU() AS BYTE
    GLOBAL Corr1() AS BYTE
    GLOBAL Corr2() AS BYTE

'Motors Vel & Accel pot tables
    GLOBAL XVel() AS LONG
    GLOBAL YVel() AS LONG
    GLOBAL XAcel() AS LONG
    GLOBAL YAcel() AS LONG

'Motors Speed Control tables
    GLOBAL XSpd()  AS LONG
    GLOBAL YSpd()  AS LONG

'   GLOBAL controlbyte AS BYTE
'   GLOBAL ExitSub AS INTEGER

'****************************************************************************************************
TYPE GloRecord

    NumModules AS INTEGER

    ModuleType(1 TO 32) AS INTEGER
    ModuleVer(1 TO 32) AS INTEGER

    StatusDef(1 TO 32) AS INTEGER        'user-defined status definition
    StatusRetBytes(1 TO 32) AS INTEGER   'number of user defined status bytes returned
    StatusByte(1 TO 32) AS INTEGER       'status byte
    StatusAux(1 TO 32) AS INTEGER        'Status Auxilary

    Position(1 TO 32) AS LONG
    CmdPosition(1 TO 32) AS LONG
    HomePosition(1 TO 32) AS LONG

    velocity(1 TO 32) AS LONG
    CmdVelocity(1 TO 32) AS LONG
    CmdAccel(1 TO 32) AS LONG
    CmdPwm(1 TO 32) AS INTEGER
    AdVal(1 TO 32) AS INTEGER


    Kp(1 TO 32) AS INTEGER         'PID
    Ki(1 TO 32) AS INTEGER
    Kd(1 TO 32) AS INTEGER
    IL(1 TO 32) AS INTEGER
    OL(1 TO 32) AS INTEGER
    CL(1 TO 32) AS INTEGER
    EL(1 TO 32) AS INTEGER
    SRD(1 TO 32) AS LONG
    DBND(1 TO 32) AS INTEGER
    SM(1 TO 32) AS INTEGER

    MiscMode(1 TO 32) AS LONG

    PathsLeft(1 TO 32) AS INTEGER        'added 6/2/15 common to PIC-SERVO and ARM-IO
    EncPosError(1 TO 32) AS INTEGER      'added 6/2/15 PIC-SERVO

    SIOErrorMode AS LONG
    SIOError AS LONG
    CkSumError AS LONG
    SIOPort AS LONG
    AmpQuery AS LONG
    PowerQuery AS LONG
    baud AS LONG

    'added for PIC-IO
    IO1 AS INTEGER
    IO2 AS INTEGER
    Ad1 AS INTEGER
    Ad2 AS INTEGER
    Ad3 AS INTEGER
    Counter AS LONG
    SyncIO1 AS INTEGER
    SyncIO2 AS INTEGER
    SyncCounter AS INTEGER

    'added for ARM-IO
    Position1 AS LONG        'added 6/2/15
    Position2 AS LONG        'added 6/2/15
    Position3 AS LONG        'added 6/2/15
    StepCount1 AS LONG       'added 6/2/15
    StepCount2 AS LONG       'added 6/2/15
    StepCount3 AS LONG       'added 6/2/15
    ImgCount1 AS LONG        'added 6/2/15
    ImgCount2 AS LONG        'added 6/2/15
    ServoFault AS INTEGER    'added 6/2/15

END TYPE
GLOBAL Glo AS GloRecord


'Installed Hardware: Specific to this particular motor controller
TYPE HardwareInstalled

    SystemModules AS INTEGER             'REQUIRED: Total Number of modules in this system
    SystemModuleType(1 TO 32) AS INTEGER 'REQUIRED: Type of module, each
    SystemModuleVer(1 TO 32) AS INTEGER  'Optional: Version number of individual module, each
    SystemName AS STRING * 20            'Optional: Name of Motor Controller Unit (MCU)
    SystemSN AS STRING * 20              'Optional: Serial Number of MCU
    SystemDate AS STRING * 6             'Optional: Date of manufacture
    SystemVersion AS STRING * 20         'Optional: MCU Version

END TYPE
GLOBAL Hardware AS HardwareInstalled



TYPE ScanParms

    YCtr        AS SINGLE       'YCts/inch
    XCtr        AS SINGLE       'XCts/inch
    ZCtr        AS SINGLE       'ZCts/Degree  '*********************************added 6/1/15
    ACtr        AS SINGLE       'Aux Enc Cts/inch
    YCal        AS SINGLE       'Y Cal Inch distance
    XCal        AS SINGLE       'X Cal Inch distance
    ZCal        AS SINGLE       'Z Cal Degree distance  '***********************added 6/1/15
    ACal        AS SINGLE       'Aux Cal Inch distance
    XOffset     AS SINGLE       'X inch pos when counter zeroed
    YOffset     AS SINGLE       'Y inch pos when counter zeroed
    ZOffset     AS SINGLE       'Z degree pos when counter zeroed '***************added 6/1/15
    AOffset     AS SINGLE       'A Inch pos when counter zeroed
    XPos        AS SINGLE       'current X inch position
    YPos        AS SINGLE       'current Y inch position
    ZPos        AS SINGLE       'current Z inch position '**********************added 6/1/15
    APos        AS SINGLE       'current A inch position
    XPlus       AS INTEGER      'X scan +/-
    YPlus       AS INTEGER      'Y scan +/-
    ZPlus       AS INTEGER      'Z scan +/- '***********************************added 6/1/15
    XDataStart  AS LONG         'x array position for scan start
    YDataStart  AS LONG         'y array position for scan start
    ZDataStart  AS LONG         'Z array position for scan start '**************added 6/1/15
    XDataEnd    AS LONG         'x array position for scan end
    YDataEnd    AS LONG         'y array position for scan end
    ZDataEnd    AS LONG         'z array position for scan end   '**************added 6/1/15
    XIndex      AS SINGLE       'x inch index
    YIndex      AS SINGLE       'y inch index
    ZIndex      AS SINGLE       'z inch index  '********************************added 6/1/15
    XIndexCts   AS LONG         'x actual value (+/-) counts per index
    YIndexCts   AS LONG         'y actual value (+/-) counts per index
    ZIndexCts   AS LONG         'z actual value (+/-) counts per index '********added 6/1/15
    IndexLow    AS INTEGER      'Index towards High or Low
    XCts        AS LONG         'x absolute value scan start counts
    YCts        AS LONG         'y absolute value scan start counts
    ZCts        AS LONG         'z absolute value scan start counts '***********added 6/1/15
    ACts        AS LONG         'a absolute value scan start counts
    XStartCts   AS LONG         'x actual value (+/-) scan start counts
    YStartCts   AS LONG         'y actual value (+/-) scan start counts
    ZStartCts   AS LONG         'z actual value (+/-) scan start counts '*******added 6/1/15
    XEndCts     AS LONG         'x actual value (+/-) scan end counts
    YEndCts     AS LONG         'y actual value (+/-) scan end counts
    ZEndCts     AS LONG         'z actual value (+/-) scan end counts   '*******added 6/1/15
    XLow        AS SINGLE       'x scan start inch position
    YLow        AS SINGLE       'y scan start inch position
    ZLow        AS SINGLE       'z scan start inch position '*******************added 6/1/15
    XHigh       AS SINGLE       'x scan end inch position
    YHigh       AS SINGLE       'y scan end inch position
    ZHigh       AS SINGLE       'z scan end inch position   '*******************added 6/1/15
    OverLap     AS SINGLE       'added si scan overlap
    XSpeed      AS SINGLE       'x scan speed in inches
    YSpeed      AS SINGLE       'y scan speed in inches
    ZSpeed      AS SINGLE       'z scan speed in inches     '*******************added 6/1/15
    XEnable     AS INTEGER      'flag true/false X axis on
    YEnable     AS INTEGER      'flag true/false Y axis on
    ZEnable     AS INTEGER      'flag true/false Z axis on  '*******************added 6/1/15
    XSpdDir     AS INTEGER      'flag X speed cntrl direction
    IndexY      AS INTEGER      'flag true/false index on X or Y, circ or ax scan
    StopChk     AS INTEGER      'flag true/false autoOff on/off
    DualRas     AS INTEGER        'flag true/false double raster each index
    AutoHold    AS INTEGER      'flag true/false Auto Hold
    IndexCt     AS INTEGER      'index loop counter
    IndexInc    AS INTEGER      'index loop incrementer
    ScanFlag    AS INTEGER      '
    Index       AS INTEGER      'scan direction
    NextFlag    AS INTEGER      'added for si auto scan increment
    YCtrStr     AS STRING * 10
    XCtrStr     AS STRING * 10
    ZCtrStr     AS STRING * 10                                    '*******************added 6/1/15
    ACtrStr     AS STRING * 10
    YCalStr     AS STRING * 10  'Y Cal Inch distance
    XCalStr     AS STRING * 10  'X Cal Inch distance
    ZCalStr     AS STRING * 10  'Z Cal Inch distance          '*******************added 6/1/15
    ACalStr     AS STRING * 10  'A Cal Inch distance
    XPosStr     AS STRING * 10
    YPosStr     AS STRING * 10
    ZPosStr     AS STRING * 10                                    '*******************added 6/1/15
    APosStr     AS STRING * 10
    XPlusSTR    AS STRING * 10
    YPlusSTR    AS STRING * 10
    ZPlusSTR    AS STRING * 10                                   '*******************added 6/1/15
    XIndexSTR   AS STRING * 10
    YIndexSTR   AS STRING * 10
    ZIndexSTR   AS STRING * 10                                  '*******************added 6/1/15
    IndexLowStr AS STRING * 10
    XLowStr     AS STRING * 10
    YLowStr     AS STRING * 10
    ZLowStr     AS STRING * 10                                    '*******************added 6/1/15
    XHighStr    AS STRING * 10
    YHighStr    AS STRING * 10
    ZHighStr    AS STRING * 10                                   '*******************added 6/1/15
    OverLapStr  AS STRING * 10
    XSpeedSTR   AS STRING * 10
    YSpeedSTR   AS STRING * 10
    ZSpeedSTR   AS STRING * 10                                  '*******************added 6/1/15
    XEnableSTR  AS STRING * 10
    YEnableSTR  AS STRING * 10
    ZEnableSTR  AS STRING * 10                                 '*******************added 6/1/15
    XSpdDirSTR  AS STRING * 10
    IndexYSTR   AS STRING * 10
    StopChkSTR  AS STRING * 10
    DualRasSTR  AS STRING * 10
    NextFlagSTR AS STRING * 10
    AutoHoldSTR AS STRING * 10

END TYPE
GLOBAL SCANstruc AS scanparms
GLOBAL x1,y1,x2,y2 AS INTEGER
GLOBAL inc AS DOUBLE


'********************************************************************************************************
'AtcoSer.inc
'***'****************************************************************************************************
' RS232 Port Control
DECLARE FUNCTION OpenComPort AS INTEGER
DECLARE SUB CloseCommPort(ComPortNum AS LONG ,ecode AS INTEGER)
DECLARE SUB FlushBuffers (ComPortNum AS LONG, WhichBuffer AS INTEGER, ECode AS INTEGER)
DECLARE SUB ReadFromComm (ComPortNum AS LONG, ReadBuffer AS STRING, BytesRead AS INTEGER, ECode AS INTEGER)
DECLARE SUB WriteToComm (ComPortNum AS LONG, WriteBuffer AS STRING, BytesWritten AS INTEGER, ECode AS INTEGER)
DECLARE SUB DeleteCommBuffers (ECode AS INTEGER)

'Serial Communication routines
DECLARE SUB BytesInQue (ComPortNum AS LONG, RecvQue AS INTEGER, XmitQue AS INTEGER, ECode AS INTEGER)
DECLARE FUNCTION InitNetWork AS INTEGER
DECLARE SUB ProcessCMD (address AS WORD, CmdString AS STRING)
DECLARE FUNCTION SIOGetByte (Character AS INTEGER, TimeOutPeriod AS INTEGER) AS INTEGER
DECLARE SUB FixSIOerror
DECLARE SUB GetStatus (Num AS INTEGER)

'new sub - specific to ARM IO
DECLARE SUB ProcessCMD (address AS WORD, CmdString AS STRING)


'Misc
'****************************************************************************************************
DECLARE SUB DelayX (Millisec AS INTEGER) '
DECLARE FUNCTION DelayFact&
DECLARE FUNCTION GetTick&

DECLARE FUNCTION BytesToLong (BYVAL A AS INTEGER, BYVAL B AS INTEGER, BYVAL C AS INTEGER, BYVAL D AS INTEGER)AS LONG
DECLARE FUNCTION LongToStr (x AS LONG) AS STRING
DECLARE FUNCTION IntToStr (x AS INTEGER) AS STRING
DECLARE FUNCTION BytesToInt (BYVAL A AS INTEGER, BYVAL B AS INTEGER) AS INTEGER

DECLARE FUNCTION QStr(BYVAL Amount AS SINGLE, BYVAL Places AS INTEGER) AS STRING

DECLARE FUNCTION GoodLNG (Num AS STRING) AS INTEGER
DECLARE FUNCTION GoodSNG (Num AS STRING) AS INTEGER


DECLARE FUNCTION KeyDown AS INTEGER


' Motor control
'************************************************************************************
DECLARE SUB SetDefaults
DECLARE SUB GetXYZAPos
DECLARE SUB SetForAuto
DECLARE SUB ResetPosition (address AS INTEGER)

DECLARE FUNCTION GetCoord (mCounts AS LONG, plus AS INTEGER) AS LONG
DECLARE SUB MoveVel (address AS INTEGER, MoveDir AS INTEGER,  velocity AS LONG, accel AS LONG)
DECLARE SUB StopMtr (address AS INTEGER, StopMode AS INTEGER)
DECLARE SUB GoMtr (address AS INTEGER)

DECLARE SUB SetHomeCap

DECLARE SUB SetAccel (address AS INTEGER)
DECLARE SUB SetGain (address AS INTEGER)
DECLARE SUB EnableAmpl (Value AS INTEGER, address AS INTEGER)
DECLARE SUB SetXCtr



'no exist, didn't pull these in, yet!
DECLARE SUB JogJoyStk
DECLARE SUB SetModePwm
DECLARE SUB SetModeVel
DECLARE SUB SetPwm (MtrNum AS INTEGER, PVal AS INTEGER)
DECLARE SUB JogAuto
DECLARE SUB JogMan
DECLARE SUB CalEncoder (YXAxis AS INTEGER)
DECLARE SUB ManXDN
DECLARE SUB ManXUP
DECLARE SUB ManYLFT
DECLARE SUB ManYRGT


'Motor Calibration File I/O
'************************************************************************************
DECLARE FUNCTION CalSave(filename AS STRING) AS INTEGER
DECLARE FUNCTION CalLoad(filename AS STRING) AS INTEGER




'IO TEST SUB
'/////////////////////////////////////////////////////////
DECLARE SUB DISPLAY(BYVAL sData AS STRING)



'<<SAVE>>
'************************************************************************************
'                           RS232 Port Control
'************************************************************************************

FUNCTION OpenComPort AS INTEGER

    LOCAL x AS INTEGER
    LOCAL ECode AS INTEGER

    COMM OPEN McuPortName AS #McuPortNum

    IF ERR THEN
       OpenComPort = FALSE
       EXIT FUNCTION
    END IF

    XmitSize = 2048
    RecvSize = 2048

    COMM SET #McuPortNum, TXBUFFER = Xmitsize   ' 2 Kb transmit buffer
    COMM SET #McuPortNum, RXBUFFER = RecvSize   ' 2 Kb receive buffer
    COMM SET #McuPortNum, BAUD   = McuPortBaud  ' 19200 baud
    COMM SET #McuPortNum, BYTE   = 8            ' 8 bits
    COMM SET #McuPortNum, PARITY = FALSE        ' No parity
    COMM SET #McuPortNum, STOP   = 0            ' 1 stop bit

    'COMM SET #McuPortNum, XINPFLOW = 0          'default is off
    'COMM SET #McuPortNum, XOUTFLOW = 0          'default is off

    FlushBuffers(McuPortNum, 0, ECode)

    OpenComPort = TRUE

END FUNCTION


SUB CloseCommPort (ComPortNum AS LONG, Ecode AS INTEGER)

    COMM CLOSE #ComPortNum   ' Close the comm port

END SUB


SUB WriteToComm (ComPortNum AS LONG, WriteBuffer AS STRING, BytesWritten AS INTEGER, ECode AS INTEGER)

    LOCAL qty AS LONG '= how many bytes are actually sent

    COMM SEND #ComPortNum, WriteBuffer TO qty
    SLEEP 200

END SUB


SUB ReadFromComm (ComPortNum AS LONG, ReadBuffer AS STRING, BytesRead AS INTEGER, Ecode AS INTEGER)

    LOCAL ncbData AS LONG    ' bytes of data waiting

    ncbData = COMM(#ComPortNum, RXQUE)  'RXQUE = Characters currently in the receive buffer (READ-ONLY).

    IF ncbData THEN
       COMM RECV #ComPortNum, 1, ReadBuffer
       BytesRead = 1
       Ecode = False
    ELSE
       BytesRead = 0
       Ecode = True
    END IF


END SUB


SUB FixSIOerror '**** NEED to add TIME-OUT EXIT - could loop forever !!!!!

    LOCAL NullStr AS STRING
    LOCAL bytesWritten, ECode, RecQue, XmtQue AS INTEGER
    LOCAL Counts, DelayCtr AS LONG

    NullStr = STRING$(16, 0)

    'spit out a bunch of zeros
    WriteToComm(McuPortNum, NullStr, BytesWritten, ECode)

    DO
        BytesInQue(McuPortNum, RecQue, XmtQue, ECode)
        Counts = Counts + 1
        IF Counts > 100 * DelayCtr THEN EXIT DO
    LOOP UNTIL (XmtQue = XmitSize - 1)  'loop until all characters are transmitted

    'wait for any responses back
    DelayX(75)


    '0= flush transmit & receive buffer; 1= flush receive buffer; 2= flush transmit buffer

    FlushBuffers(McuPortNum, 0, ECode)'flush the receive buffer that may contain any responses

END SUB


SUB FlushBuffers (ComPortNum AS LONG, WhichBuffer AS INTEGER, ECode AS INTEGER)

    LOCAL Qty AS LONG
    LOCAL emptybuffer AS STRING

    IF (WhichBuffer = 1) OR (WhichBuffer = 0) THEN 'flush receive buffer
        Qty = COMM(#ComPortNum, RXQUE)
        IF Qty THEN
           COMM RECV #ComPortNum, Qty, emptybuffer
        END IF
    END IF


    IF (WhichBuffer = 2) OR (WhichBuffer = 0) THEN 'flush transmit buffer

       'how do you flush transmit buffer???

    END IF

END SUB


SUB BytesInQue (ComPortNum AS LONG, RecvQue AS INTEGER, XmitQue AS INTEGER, ECode AS INTEGER)

    'RecvQue = number of characters in the receive buffer; maximum = (receive buffer size - 1)
    'XmitQue = number of character space available in the transmit buffer; maximum space = (transmit buffer size - 1)
    'Ecode = error code returned if any problems getting info from receive or transmit buffer

    XmitQue = COMM(#ComPortNum, TXQUE) 'TXQUE = Characters currently in the transmit buffer (READ-ONLY).
    RecvQue = COMM(#ComPortNum, RXQUE) 'RXQUE = Characters currently in the receive buffer (READ-ONLY).


END SUB




'************************************************************************************
'                   Process NMC Serial Comunications
'************************************************************************************

'************************************************************************************
'                            Intialize NMC Network
'************************************************************************************

FUNCTION InitNetWork AS INTEGER

    LOCAL ECode, ModuleNo AS INTEGER
    LOCAL Cmd AS STRING

    'Initial Varibles
    Glo.SIOErrorMode = DoNothing
    Glo.SIOError = 0
    Glo.CkSumError = FALSE
    Glo.NumModules = 0
    Glo.AmpQuery = TRUE
    Glo.PowerQuery = TRUE


    'REQUIRED: Set number of modules in THIS system
    Hardware.SystemModules = 6

    'REQUIRED: Define each module in THIS system, in address order location.
    '          use pre-defined CONST, up to 32 modules supported
    Hardware.SystemModuleType(1) = PicServoID
    Hardware.SystemModuleType(2) = PicServoID
    Hardware.SystemModuleType(3) = PicServoID
    Hardware.SystemModuleType(4) = PicServoID
    Hardware.SystemModuleType(5) = PicIoID
    Hardware.SystemModuleType(6) = ArmIoID

    'start network

    'flush the input buffer
    FlushBuffers(McuPortNum, 0, ECode)

    Glo.SIOErrorMode = DoNothing

    'reset controllers
    Cmd = CHR$(&HF)  'reset all modules
    ProcessCMD &HFF, Cmd  'default group command
    DelayX(200)

    FOR ModuleNo = 1 TO Hardware.SystemModules

        Glo.StatusDef(ModuleNo) = 0
        Glo.StatusRetBytes(ModuleNo) = 2   'Status byte + Checksum Byte - no additional status bytes

        IF Hardware.SystemModuleType(ModuleNo) = PicServoID THEN    'Set address from 0 to ModuleNo and Group to &HFF
            SetAddress_0x01(0, ModuleNo, &HFF)
        ELSEIF Hardware.SystemModuleType(ModuleNo) = PicIoID THEN   'Set address from 0 to ModuleNo and Group to &HFE
            SetAddress_0x01(0, ModuleNo, &HFE)
        ELSEIF Hardware.SystemModuleType(ModuleNo) = ArmIoID THEN   'Set address from 0 to ModuleNo and Group to &HFD
            SetAddress_0x01(0, ModuleNo, &HFD)
        END IF

        Glo.ModuleType(ModuleNo) = Hardware.SystemModuleType(ModuleNo)
        ReadStatus_0x03(ModuleNo, &H20)  'read status one time, get device ID only.

        IF Glo.SIOError THEN   'exit if serial port error
           ECode = 2
           InitNetWork = 0
           EXIT FUNCTION
        END IF

        IF Glo.ModuleType(ModuleNo) <> Hardware.SystemModuleType(ModuleNo) THEN  'exit if module doesn't match specified hardware
           ECode = 3
           InitNetWork = 0
           EXIT FUNCTION
        END IF

    NEXT

    FlushBuffers(McuPortNum, 0, ECode)

    InitNetWork = TRUE

    EXIT FUNCTION

END FUNCTION


'added ARM IO
SUB ProcessCMD (address AS WORD, CmdString AS STRING)

    LOCAL Cksum AS INTEGER
    LOCAL CmdPkt AS STRING
    LOCAL i AS INTEGER
    LOCAL StatusData AS STRING
    LOCAL BytesWritten, ECode AS INTEGER
    LOCAL ActPos AS LONG
    LOCAL StatPtr, NumOfBytes AS INTEGER

    Glo.SIOError = False

    Cksum = address
    FOR i = 1 TO LEN(CmdString)
        Cksum = Cksum + ASC(MID$(CmdString, i, 1))
    NEXT i
    Cksum = (Cksum AND 255)

    'Build the command packet string
    CmdPkt = CHR$(&HAA) + CHR$(address) + CmdString + CHR$(Cksum)

    WriteToComm(McuPortNum, CmdPkt, BytesWritten, ECode)

    IF address > 32 THEN EXIT SUB 'group command - exit now

    NumOfBytes = Glo.StatusRetBytes(address)              'number of return bytes expected
    StatusData = RcvStatus(McuPortNum, NumOfBytes, ECode) 'get status string from serial port

    'Check for Error Code
    IF ECode THEN  'some kind of error in received serial packet
        IF ECode = 1 THEN     'timeout error, no response

        ELSEIF ECode = 2 THEN 'Send command packet checksum error

        ELSEIF ECode = 3 THEN 'Received status packet checksum errror

        END IF
        Glo.SIOError = TRUE
        FixSIOerror
        EXIT SUB
    END IF

    IF NOT Glo.StatusDef(address) THEN EXIT SUB  'Exit now if no additional status requested

    'use new address value if change address command
    IF ASC(MID$(CmdString, 1, 1)) = &H21 THEN address = ASC(MID$(CmdString, 2, 1))

    'remmed out 6/6/15  IF address = 0 THEN address = 1 'for testing on axis 0

    'status byte is first in string, additional status bytes start at position 2
    StatPtr = 2

    IF Glo.ModuleType(address) = PicServoID THEN 'pic servo

        IF (Glo.StatusDef(address) AND SendPos) THEN  'encoder position
            Glo.Position(address) = CVL(MID$(StatusData,StatPtr,4))
            StatPtr = StatPtr + 4
        END IF

        IF (Glo.StatusDef(address) AND SendAD) THEN  'A/D value
            Glo.AdVal(address) = ASC(MID$(StatusData,StatPtr,1))
            StatPtr = StatPtr + 1
        END IF

        IF (Glo.StatusDef(address) AND SendVel) THEN  'Velocity data
            Glo.velocity(address) = CVI(MID$(StatusData,StatPtr,2))
            StatPtr = StatPtr + 2
        END IF

        IF (Glo.StatusDef(address) AND SendAux) THEN  'AUX status value
            Glo.StatusAux(address) = ASC(MID$(StatusData,StatPtr,1))
            StatPtr = StatPtr + 1
        END IF

        IF (Glo.StatusDef(address) AND SendHome) THEN  'Home position data
            Glo.HomePosition(address) = CVL(MID$(StatusData,StatPtr,4))
            StatPtr = StatPtr + 4
        END IF

        IF (Glo.StatusDef(address) AND SendID) THEN   'Module type and version
            Glo.ModuleType(address) = ASC(MID$(StatusData,StatPtr,1))
            Glo.ModuleVer(address) = ASC(MID$(StatusData,StatPtr+1,1))
            StatPtr = StatPtr + 2
        END IF

        IF (Glo.StatusDef(address) AND SendPosErr) THEN 'Current encoder position error
            Glo.EncPosError(address) = CVI(MID$(StatusData,StatPtr,2))
            StatPtr = StatPtr + 2
        END IF

        IF (Glo.StatusDef(address) AND SendPathLeft) THEN  'Number of path points left in path buffer
            Glo.PathsLeft(address) = ASC(MID$(StatusData,StatPtr,1))
            StatPtr = StatPtr + 1
        END IF


    ELSEIF Glo.ModuleType(address) = PicIoID THEN 'PicIO module

        IF (Glo.StatusDef(address) AND SendIO) THEN   'I/O Input bit values
            Glo.IO1 = ASC(MID$(StatusData,StatPtr,1))
            Glo.IO2 = ASC(MID$(StatusData,StatPtr+1,1))
            StatPtr = StatPtr + 2
        END IF

        IF (Glo.StatusDef(address) AND SendAD1) THEN  'A/D 1 value
            Glo.Ad1 = ASC(MID$(StatusData,StatPtr,1))
            StatPtr = StatPtr + 1
        END IF

        IF (Glo.StatusDef(address) AND SendAD2) THEN  'A/D 2 value
            Glo.Ad2 = ASC(MID$(StatusData,StatPtr,1))
            StatPtr = StatPtr + 1
        END IF

        IF (Glo.StatusDef(address) AND SendAD3) THEN  'A/D 3 value
            Glo.Ad3 = ASC(MID$(StatusData,StatPtr,1))
            StatPtr = StatPtr + 1
        END IF

        IF (Glo.StatusDef(address) AND SendCtr) THEN  'Counter/timer value
            Glo.Counter = CVL(MID$(StatusData,StatPtr,4))
            StatPtr = StatPtr + 4
        END IF

        IF (Glo.StatusDef(address) AND SendID) THEN   'Device module type and version
            Glo.ModuleType(address) = ASC(MID$(StatusData,StatPtr,1))
            Glo.ModuleVer(address) = ASC(MID$(StatusData,StatPtr+1,1))
            StatPtr = StatPtr + 2
        END IF

        IF (Glo.StatusDef(address) AND SendSyncIO) THEN 'Input bit values captured with the Sync Input command
            Glo.SyncIO1 = ASC(MID$(StatusData,StatPtr,1))
            Glo.SyncIO2 = ASC(MID$(StatusData,StatPtr+1,1))
            StatPtr = StatPtr + 2
        END IF

        IF (Glo.StatusDef(address) AND SendSyncCtr) THEN 'Counter/timer value captured with the Sync Input command
            Glo.SyncCounter = CVL(MID$(StatusData,StatPtr,4))
            StatPtr = StatPtr + 4
        END IF


    ELSEIF Glo.ModuleType(address) = ArmIoID THEN  'ARM-IO module

        IF (Glo.StatusDef(address) AND SendEnc123) THEN 'Encoder 1,2 & 3 counts
            Glo.Position1 = CVL(MID$(StatusData,StatPtr,4))
            Glo.Position2 = CVL(MID$(StatusData,StatPtr+4,4))
            Glo.Position3 = CVL(MID$(StatusData,StatPtr+8,4))
            StatPtr = StatPtr + 12
        END IF

        IF (Glo.StatusDef(address) AND SendStp123) THEN 'Step output 1,2 & 3 counts
            Glo.StepCount1 = CVL(MID$(StatusData,StatPtr,4))
            Glo.StepCount2 = CVL(MID$(StatusData,StatPtr+4,4))
            Glo.StepCount3 = CVL(MID$(StatusData,StatPtr+8,4))
            StatPtr = StatPtr + 12
        END IF

        IF (Glo.StatusDef(address) AND SendImg12) THEN  'Image output 1 & 2 counts
            Glo.ImgCount1 = CVL(MID$(StatusData,StatPtr,4))
            Glo.ImgCount2 = CVL(MID$(StatusData,StatPtr+4,4))
            StatPtr = StatPtr + 8
        END IF

        IF (Glo.StatusDef(address) AND SendID) THEN      'Device module type and version
            Glo.ModuleType(address) = ASC(MID$(StatusData,StatPtr,1))
            Glo.ModuleVer(address) = ASC(MID$(StatusData,StatPtr+1,1))
            StatPtr = StatPtr + 2
        END IF

        IF (Glo.StatusDef(address) AND SendFaultStop) THEN 'Servo 1,2& 3 and E-Stop fault state
            Glo.ServoFault= ASC(MID$(StatusData,StatPtr,1))
            StatPtr = StatPtr + 1
        END IF


        IF (Glo.StatusDef(address) AND SendPathLeft) THEN  'Number of path points left in path buffer
            Glo.PathsLeft(address) = CVI(MID$(StatusData,StatPtr,2))
            StatPtr = StatPtr + 2
        END IF

    ELSE

        'PRINT "ERROR ProcessCMD Unidentified Module"

    END IF


END SUB


'Read in entire status string in one shot!!
FUNCTION RcvStatus (ComPortNum AS LONG, NumofBytes AS INTEGER, ECode AS INTEGER) AS STRING

    LOCAL RetStr AS STRING
    LOCAL StatByte, ChkSum, RxBytes, RcvdBytes, i AS INTEGER
    LOCAL TimeA##, TimeB##  'timer:

    TimeA = TIMER : TimeB = 1.00##

    DO

        RxBytes = COMM(#ComPortNum, RXQUE)  'RXQUE = Characters currently in the receive buffer (READ-ONLY).
        IF RxBytes = NumOfBytes THEN
            RcvdBytes = 1
            EXIT DO
        END IF

    LOOP WHILE ABS(TimeA-TIMER) < TimeB  ' timeout after 1 second

    IF RcvdBytes = 1 THEN

        COMM RECV #ComPortNum, NumOfBytes, RetStr
        StatByte = ASC(RetStr) 'get the status byte
        IF (StatByte AND &H2) THEN  'Command packet sent has checksum error
            ECode = 2
            EXIT FUNCTION
        END IF

        'Check status data for checksum error
        FOR i = 1 TO (NumofBytes-1) ' -1 : last byte is module returned checksum
            ChkSum = ChkSum + ASC(MID$(RetStr,i,1))
        NEXT i

        ChkSum = ChkSum AND 255

        IF ChkSum <> ASC(RIGHT$(RetStr,1)) THEN 'Status packet received has checksum errror
            ECode = 3
          EXIT FUNCTION
        END IF

        'all is good, return the entire status package to the caller and exit
        ECode = 0
        RcvStatus = RetStr
        EXIT FUNCTION

    ELSE   'timed out with none or short serial package

        ECode = 1
        RcvStatus = ""
        EXIT FUNCTION

    END IF


END FUNCTION


'determine number of return bytes at current status setting
FUNCTION StatusBytes(address AS INTEGER, ControlByte AS INTEGER) AS INTEGER

    LOCAL NumofBytes AS INTEGER

    NumofBytes = 2 'Status byte + Checksum byte

    IF Glo.ModuleType(address) = PicServoID THEN 'Pic Servo

        IF (ControlByte AND SendPos) THEN NumofBytes = NumofBytes + 4       'encoder position
        IF (ControlByte AND SendAD) THEN NumOfBytes = NumOfBytes + 1        'A/D value
        IF (ControlByte AND SendVel) THEN NumOfBytes = NumOfBytes + 2       'Velocity data
        IF (ControlByte AND SendAux) THEN NumOfBytes = NumOfBytes + 1       'AUX status value
        IF (ControlByte AND SendHome) THEN NumOfBytes = NumOfBytes + 4      'Home position data
        IF (ControlByte AND SendID) THEN NumOfBytes = NumOfBytes + 2        'Module type and version
        IF (ControlByte AND SendPosErr) THEN NumOfBytes = NumOfBytes + 2    'Current encoder position error
        IF (ControlByte AND SendPathLeft) THEN NumOfBytes = NumOfBytes + 1  'Number of path points left in path buffer

    ELSEIF Glo.ModuleType(address) = PicIoID THEN 'Pic IO

        IF (ControlByte AND SendIO) THEN NumOfBytes = NumOfBytes + 2        'I/O Input bit values
        IF (ControlByte AND SendAD1) THEN NumOfBytes = NumOfBytes + 1       'A/D 1 value
        IF (ControlByte AND SendAD2) THEN NumOfBytes = NumOfBytes + 1       'A/D 2 value
        IF (ControlByte AND SendAD3) THEN NumOfBytes = NumOfBytes + 1       'A/D 3 value
        IF (ControlByte AND SendCtr) THEN NumOfBytes = NumOfBytes + 4       'Counter/timer value
        IF (ControlByte AND SendID) THEN NumOfBytes = NumOfBytes + 2        'Device module type and version
        IF (ControlByte AND SendSyncIO) THEN NumOfBytes = NumOfBytes + 2    'Input bit values captured with the Sync Input command
        IF (ControlByte AND SendSyncCtr) THEN NumOfBytes = NumOfBytes + 4   'Counter/timer value captured with the Sync Input command

    ELSEIF Glo.ModuleType(address) = ArmIoID THEN  'Arm IO

        IF (ControlByte AND SendEnc123) THEN NumOfBytes = NumOfBytes + 12   'Encoder 1,2 & 3 counts
        IF (ControlByte AND SendStp123) THEN NumOfBytes = NumOfBytes + 12   'Step output 1,2 & 3 counts
        IF (ControlByte AND SendImg12) THEN NumOfBytes = NumOfBytes + 8     'Image output 1 & 2 counts
        'bit 3 unused
        'bit 4 unused
        IF (ControlByte AND SendID) THEN NumOfBytes = NumOfBytes + 2        'Device module type and version
        IF (ControlByte AND SendFaultStop) THEN NumOfBytes = NumOfBytes + 1 'Servo 1,2& 3 and E-Stop fault state
        IF (ControlByte AND SendPathLeft) THEN NumOfBytes = NumOfBytes + 2  'Number of path points left in path buffer

    ELSE

        'PRINT "ERROR ProcessCMD Unidentified Module"

        'NumOfBytes = 0
    END IF


   StatusBytes = NumOfBytes

   EXIT FUNCTION


END FUNCTION



'************************************************************************************
'                    NMC Motor Control Routines
'************************************************************************************

'0x00 PIC-SERVO SPECIFIC COMMAND
'PIC SERVO: Reset Position
'PIC IO:  : Set Direction
'ARM IO:  : Set Encoders
SUB ResetPosition_0x00 (address AS INTEGER, ControlByte AS INTEGER)

    LOCAL Cmd AS STRING

    Cmd = CHR$(&H0)

    ProcessCMD address, Cmd

END SUB


'0x00 PIC-IO SPECIFIC COMMAND
'PIC SERVO: Reset Position
'PIC IO   : Set Direction
'ARM IO   : Set Encoders
SUB SetDirection_0x00 (address AS INTEGER, ControlByte AS INTEGER)

    LOCAL Cmd AS STRING

    Cmd = CHR$(&H0)

    ProcessCMD address, Cmd

END SUB


'0x00 ARM-IO SPECIFIC COMMAND
'PIC SERVO: Reset Position
'PIC IO   : Set Direction
'ARM IO   : Set Encoders
SUB SetEncoders_0x00 (address AS INTEGER, ControlByte AS INTEGER)

    LOCAL Cmd AS STRING

    Cmd = CHR$(&H0)

    ProcessCMD address, Cmd

END SUB


'0x01 *COMMON NMC COMMAND*
'PIC SERVO: Set Address
'ARM IO   : SAME
'PIC IO   : SAME
SUB SetAddress_0x01 (Address AS INTEGER, NewAddress AS INTEGER, GroupAddress AS INTEGER)

    LOCAL Cmd AS STRING

    Cmd = CHR$(&H21) + CHR$(NewAddress) + CHR$(GroupAddress)
    ProcessCMD Address, Cmd

END SUB


'0x02 *COMMON NMC COMMAND*      / ControlByte specific to module type
'PIC SERVO: Define Status  -Persistant! Status returned as defined in CotrolByte with every subsequent status request
'PIC IO   : SAME
'ARM IO   : SAME
SUB DefineStatus_0x02 (address AS INTEGER, ControlByte AS INTEGER)

    LOCAL Cmd AS STRING

    'get number of return bytes at current status setting
    Glo.StatusRetBytes(address) = StatusBytes(address, ControlByte)

    Glo.StatusDef(address) = ControlByte

    Cmd = CHR$(&H12) + CHR$(ControlByte)
    ProcessCMD address, Cmd

END SUB


'0x03 *COMMON NMC COMMAND*     / ControlByte specific to module type
'PIC SERVO: Read Status   -One time! Status bytes returned as defined in ControlByte
'PIC IO   : SAME
'ARM IO   : SAME
SUB ReadStatus_0x03 (address AS INTEGER, ControlByte AS INTEGER)  'modified to handle ARM IO module

    LOCAL Cmd AS STRING
    LOCAL NumofBytes, CurrentStatusRetBytes, CurrentStatusDef  AS INTEGER

    'get total number of bytes at current status setting
    NumofBytes = StatusBytes(address, ControlByte)

    'temp store total number return bytes
    CurrentStatusRetBytes = Glo.StatusRetBytes(address)

    'temp store current status definition
    CurrentStatusDef = Glo.StatusDef(address)

    'set global status to temp status return bytes
    Glo.StatusRetBytes(address) = NumofBytes

    'set to temp status definition
    Glo.StatusDef(address) = ControlByte

    'get the requested status
    Cmd = CHR$(&H13) + CHR$(ControlByte)
    ProcessCMD address, Cmd

    'set back to original value
    Glo.StatusRetBytes(address) = CurrentStatusRetBytes
    Glo.StatusDef(address) = CurrentStatusDef

END SUB


'0x04 PIC-SERVO SPECIFIC COMMAND
'PIC SERVO: Load Trajectory
'PIC IO   : Set PWM
'ARM IO   : Not Used
SUB LoadTrajectory_0x04 (address AS INTEGER, ControlByte AS INTEGER)

    LOCAL Cmd AS STRING
    LOCAL CmdStr AS STRING
    LOCAL CmdNum AS BYTE
    LOCAL CmdBytes AS INTEGER

    LOCAL test AS LONG

    'make sure module is a Pic Servo
    IF Glo.ModuleType(address) <> PicServoID THEN EXIT SUB  'Print "ERROR: Not Servo"

    CmdBytes = 1 'minium control byte + any additional motion bytes below

    IF (ControlByte AND LoadPos) THEN
        CmdStr = CmdStr + MKL$(test)
        CmdBytes = CmdBytes + 4
    END IF

    IF (ControlByte AND LoadVel) THEN
        CmdStr = CmdStr + MKL$(test)
        CmdBytes = CmdBytes + 4
    END IF

    IF (ControlByte AND LoadAcc) THEN
        CmdStr = CmdStr + MKL$(test)
        CmdBytes = CmdBytes + 4
    END IF

    IF (ControlByte AND LoadPWM) THEN
        CmdStr = CmdStr + CHR$(test)
        CmdBytes = CmdBytes + 1
    END IF

    SHIFT LEFT CmdBytes, 4 'upper nibble = total number of bytes being send
    CmdNum = CmdBytes OR &H4  'lower nibble = command number

    'build the command string
    Cmd = CHR$(CmdNum) + CHR$(ControlByte) + CmdStr

    ProcessCMD address, Cmd


END SUB


'0x04 PIC-IO SPECIFIC COMMAND
'PIC SERVO: Load Trajectory
'PIC IO   : Set PWM
'ARM IO   : Not Used
SUB SetPWM_0x04 (address AS INTEGER, pwm1 AS INTEGER, pwm2 AS INTEGER)

    LOCAL Cmd AS STRING

    'make sure module is a Pic Servo OR Arm IO
    IF Glo.ModuleType(address) <> PicIoID THEN EXIT SUB  'Print "ERROR: Not PicIO"

    Cmd = CHR$(&H24) + CHR$(pwm1) + CHR$(pwm2)

    ProcessCMD address, Cmd

END SUB



'0x05 PIC-SERVO & ARM-IO SPECIFIC COMMAND
'PIC SERVO: Start Motion
'PIC IO   : Synch Output / Starts PWM output
'ARM IO   : Start Motion
SUB StartMotion_0x05 (address AS INTEGER)

    LOCAL Cmd AS STRING

    'make sure module is a Pic Servo OR Arm IO
    IF Glo.ModuleType(address) <> PicServoID THEN EXIT SUB  'Print "ERROR: Not Servo"
    IF Glo.ModuleType(address) <> ArmIoID THEN EXIT SUB  'Print "ERROR: Not Arm"

    Cmd = CHR$(&H5)
    ProcessCMD address, Cmd

END SUB


'0x05 PIC-IO SPECIFIC COMMAND
'PIC SERVO: Start Motion
'PIC IO   : Synch Output / Starts PWM output
'ARM IO   : Start Motion
SUB SynchOutput_0x05 (address AS INTEGER)

    LOCAL Cmd AS STRING

    'make sure module is a Pic IO
    IF Glo.ModuleType(address) <> PicIoID THEN EXIT SUB  'Print "ERROR: Not PicIO"

    Cmd = CHR$(&H5)

    ProcessCMD address, Cmd

END SUB



'0x06 PIC-SERVO SPECIFIC COMMAND
'PIC SERVO: Set Gain
'PIC IO   : Set Output
'ARM IO   : NOT USED
SUB SetGain_0x06 (address AS INTEGER)

    LOCAL Cmd AS STRING

    'make sure module is a Pic Servo
    IF Glo.ModuleType(address) <> PicServoID THEN EXIT SUB  'Print "ERROR: Not Servo"

    'make sure current limit checking is turned off. When on, analog input determines
    'motor current limit. This input is being used to read a user pot control!
    Glo.CL(address) = 0 'turn off current limiting

    Cmd = CHR$(&HF6) + MKI$(Glo.Kp(address)) + MKI$(Glo.Kd(address))
    Cmd = Cmd + MKI$(Glo.Ki(address)) + MKI$(Glo.IL(address))
    Cmd = Cmd + CHR$(Glo.ol(address)) + CHR$(Glo.CL(address)  )
    Cmd = Cmd + MKI$(Glo.EL(address)) + CHR$(Glo.SRD(address))
    Cmd = Cmd + MKI$(Glo.DBND(address)) + CHR$(Glo.SM(address))

    ProcessCMD address, Cmd

END SUB


'0x06 PIC-IO SPECIFIC COMMAND
'PIC SERVO: Set Gain
'PIC IO   : Set Output
'ARM IO   : NOT USED
SUB SetOutput_0x06 (address AS INTEGER, Bits_1to8 AS INTEGER, Bits_9to12 AS INTEGER)

    LOCAL Cmd AS STRING

    'make sure module is a Pic IO
    IF Glo.ModuleType(address) <> PicIoID THEN EXIT SUB  'Print "ERROR: Not PIC IO"

    Cmd = CHR$(&H26) + CHR$(Bits_1to8) + CHR$(Bits_9to12)

    ProcessCMD address, Cmd

END SUB


'0x07 PIC-SERVO SPECIFIC COMMAND
'PIC SERVO: Stop Motor
'PIC IO   : Set Synch Output
'ARM IO   : Stop Motion
SUB StopMotor_0x07 (address AS INTEGER, StopMode AS INTEGER, StopPosition AS LONG)

    LOCAL Cmd AS STRING

    'make sure module is a Pic Servo
    IF Glo.ModuleType(address) <> PicServoID THEN EXIT SUB  'Print "ERROR: Not Servo"

    IF StopMode AND &H10 THEN '0b00010000 bit 4 set, stop at StopPosition
       Cmd = CHR$(&H57) + CHR$(StopMode) + MKL$(StopPosition)
    ELSE
       Cmd = CHR$(&H17) + CHR$(StopMode)
    END IF

    ProcessCMD address, Cmd

END SUB


'0x07 PIC-IO SPECIFIC COMMAND
'PIC SERVO: Stop Motor
'PIC IO   : Set Synch Output
'ARM IO   : Stop Motion
SUB SetSynchOutput_0x07 (address AS INTEGER, Bits_1to8 AS INTEGER, Bits_9to12 AS INTEGER, pwm1 AS INTEGER, pwm2 AS INTEGER )

    LOCAL Cmd AS STRING

    'make sure module is a Pic IO
    IF Glo.ModuleType(address) <> PicIoID THEN EXIT SUB  'Print "ERROR: Not PIC-IO"

    Cmd = CHR$(&H47) + CHR$(Bits_1to8) + CHR$(Bits_9to12) + CHR$(pwm1) + CHR$(pwm2)

    ProcessCMD address, Cmd

END SUB


'0x07 ARM-IO SPECIFIC COMMAND
'PIC SERVO: Stop Motor
'PIC IO   : Set Synch Output
'ARM IO   : Stop Motion
SUB StopMotion_0x07 (address AS INTEGER, StopMode AS INTEGER)

    LOCAL Cmd AS STRING

    'make sure module is Arm IO
    IF Glo.ModuleType(address) <> ArmIoID THEN EXIT SUB  'Print "ERROR: Not Arm IO"

    Cmd = CHR$(&H17) + CHR$(StopMode)

    ProcessCMD address, Cmd

END SUB



'0x08 PIC-SERVO SPECIFIC COMMAND
'PIC SERVO: I/O Control
'PIC IO   : Set Timer Mode
'ARM IO   : Test for Encoder Position Error
SUB IoControl_0x08 (address AS INTEGER, ControlByte AS INTEGER)

    LOCAL Cmd AS STRING

    'make sure module is Pic Servo
    IF Glo.ModuleType(address) <> PicServoID THEN EXIT SUB  'Print "ERROR: Not Pic Servo"

    'build the command string
    Cmd = CHR$(&H18) + CHR$(ControlByte)

    ProcessCMD address, Cmd

END SUB


'0x08 PIC-IO SPECIFIC COMMAND
'PIC SERVO: I/O Control
'PIC IO   : Set Timer Mode
'ARM IO   : Test for Encoder Position Error
SUB SetTimerMode_0x08 (address AS INTEGER, ControlByte AS INTEGER)

    LOCAL Cmd AS STRING

    'make sure module is Pic IO
    IF Glo.ModuleType(address) <> PicIoID THEN EXIT SUB  'Print "ERROR: Not Pic IO"

    'build the command string
    Cmd = CHR$(&H18) + CHR$(ControlByte)

    ProcessCMD address, Cmd

END SUB


'0x08 ARM IO SPECIFIC COMMAND
'PIC SERVO: I/O Control
'PIC IO   : Set Timer Mode
'ARM IO   : Test for Encoder Position Error
SUB SetPosError_0x08 (address AS INTEGER, ControlByte AS INTEGER, SmoothEncCts AS INTEGER)

    LOCAL Cmd AS STRING

    'make sure module is ARM IO
    IF Glo.ModuleType(address) <> ArmIoID THEN EXIT SUB  'Print "ERROR: Not ARM IO"

    'build the command string
    Cmd = CHR$(&H38) + CHR$(ControlByte) + MKI$(SmoothEncCts)

    ProcessCMD address, Cmd

END SUB


'0x09 PIC-SERVO SPECIFIC COMMAND
'PIC SERVO: Set Homing
'PIC IO   : Not Used
'ARM IO   : Not Used
SUB SetHoming_0x09 (address AS INTEGER, ControlByte AS INTEGER)

    LOCAL Cmd AS STRING

    'make sure module is a Pic Servo
    IF Glo.ModuleType(address) <> PicServoID THEN EXIT SUB  'Print "ERROR: Not Servo"

    Cmd = CHR$(&H19) + CHR$(ControlByte)

    ProcessCMD address, Cmd

END SUB


'0x0A COMMON NMC COMMAND
'PIC SERVO: Set Baud
'PIC IO   : SAME
'ARM IO   : SAME
SUB SetBaud_0x0A (address AS INTEGER, BaudRate AS INTEGER)

    LOCAL Cmd AS STRING

    Cmd = CHR$(&H1A) + CHR$(Address) + CHR$(BaudRate)
    ProcessCMD address, Cmd

END SUB


'0x0B PIC-SERVO and ARM-IO COMMON COMMAND
'PIC SERVO: Clear Bits
'PIC IO   : Not Used
'ARM IO   : Clear Latched Bits
SUB ClearBits_0x0B (address AS INTEGER)

    LOCAL Cmd AS STRING

    'make sure module is not PicIoID
    IF Glo.ModuleType(address) = PicIoID THEN EXIT SUB  'Print "ERROR: Not for PIC IO use"

    Cmd = CHR$(&H0B)
    ProcessCMD address, Cmd

END SUB


'0x0C PIC-SERVO and PIC-IO NMC COMMON COMMAND  / common NMC command, although data saved is not the same.
'PIC SERVO: Save as Home
'PIC IO   : Synch Input
'ARM IO   : Send Output counts to image system
SUB SaveAsHome_0xOC(address AS INTEGER)

    LOCAL Cmd AS STRING

    'make sure module is not ARM IO
    IF Glo.ModuleType(address) = ArmIoID THEN EXIT SUB  'Print "ERROR: Not for Arm IO use "

    'build the command string
    Cmd = CHR$(&H0C)

    ProcessCMD address, Cmd

END SUB


'0x0C PIC-SERVO and PIC-IO NMC COMMON COMMAND  / common NMC command, although data saved is not the same.
'PIC SERVO: Save as Home
'PIC IO   : Synch Input
'ARM IO   : Send Output counts to image system
SUB SynchInput_0xOC(address AS INTEGER)

    SaveAsHome_0xOC address

END SUB


'0x0C ARM IO SPECIFIC
'PIC SERVO: Save as Home
'PIC IO   : Synch Input
'ARM IO   : Send Output counts to image system
SUB SendCounts_0x0C(address AS INTEGER, StepCounts AS INTEGER)

    LOCAL Cmd AS STRING

    'make sure module is ARM IO
    IF Glo.ModuleType(address) <> ArmIoID THEN EXIT SUB  'Print "ERROR: Not Arm IO "

    'build the command string
    Cmd = CHR$(&H3C) + MKI$(StepCounts)

    ProcessCMD address, Cmd

END SUB


'0x0D PIC SERVO SPECIFIC    Same function but not Compatible with ARM_IO
'PIC SERVO: Add Path Points
'PIC IO   : Not Used
'ARM IO   : Add Path Points
SUB AddPathPointsPIC_0x0D(address AS INTEGER, numofpaths AS INTEGER, pathbegin AS INTEGER, pathend AS INTEGER, patharray() AS INTEGER, hertz AS INTEGER, fastpath AS INTEGER)

    LOCAL Cmd, pathstr AS STRING

    LOCAL arraymin, arraymax  AS INTEGER

    LOCAL pathctr, pathdata, pathnum, pathpoint, pathbytes AS INTEGER

    LOCAL dirbit, freqbit, shiftnum AS INTEGER

    'make sure module is a Pic Servo
    IF Glo.ModuleType(address) <> PicServoID THEN EXIT SUB  'Print "ERROR: Not Servo"

    'get array boundrys
    arraymin = LBOUND(patharray) : arraymax = UBOUND(patharray)

    'compare array bounds to number of paths
    IF ( ((arraymax-arraymin)+1) < numofpaths ) THEN
       'Print "ERROR IN AddPathPIC SUB"
       EXIT SUB
    END IF

    'compare array lower bound to path array begin
    IF ( pathbegin < arraymin ) THEN
       'Print "ERROR IN AddPathPIC SUB"
       EXIT SUB
    END IF

    'compare array upper bound to path array end
    IF ( pathend > arraymax ) THEN
       'Print "ERROR IN AddPathPIC SUB"
       EXIT SUB
    END IF

    pathctr = 1

    '!! NEED to add check for PIC path Buffer FULL status before sending continuous path data!!

    FOR pathnum = pathbegin TO pathend

        IF patharray(pathnum) < 0 THEN  'negative path
           pathpoint = ABS(patharray(pathnum))
           dirbit = 1                   'reverse diretction
        ELSE
           pathpoint = patharray(pathnum)
           dirbit = 0                   'forward direction
        END IF

        IF hertz = 120 THEN             'fast path
           shiftnum = 4                 '12 bit path point
           freqbit = 0
        ELSEIF hertz = 60 THEN
           shiftnum = 3                 '13 bit path point
           freqbit = 0
           IF fastpath THEN freqbit = 2
        ELSEIF hertz = 30 THEN
           shiftnum = 2                 '14 bit path point
           freqbit = 2
        END IF

        'Format path point
        SHIFT LEFT pathpoint, shiftnum              'shift pathpoint bits left by 'shiftnum' places
        pathdata = (pathpoint OR freqbit OR dirbit) 'add dir and freq bits for path data point

        'Convert path numeric data to string and add it to path command string
        pathstr = pathstr + MKI$(pathdata)          'add the next data point to the path string

        'check for end of path array
        IF pathnum = pathend THEN                   'last path - send cmd string and exit!
           PathBytes = pathctr * 2                  '2 bytes for each path
           SHIFT LEFT PathBytes, 4                  'shift 4 bits left
           Cmd = CHR$(PathBytes OR &HD) + pathstr   'build the complete command string
           ProcessCMD address, Cmd                  'send command string
           EXIT FOR                                 'exit sub
        END IF

        'check to not exceed max allowable (7) path points per command string
        IF pathctr = 7  THEN                        'ctr at max path - send cmd string now
           Cmd = CHR$(&HED) + pathstr               '7 paths * 2 bytes = 14 bytes = &HEx
           ProcessCMD address, Cmd                  'send the command string
           pathstr = ""                             'reset pathstr
           pathctr = 0                              'reset pathctr to 0, incrm' to 1 below
        END IF

        INCR pathctr  'bump up 1

    NEXT


END SUB


'0x0D ARM IO SPECIFIC       Same function but not Compatible with PIC_SERVO
'PIC SERVO: Add Path Points
'PIC IO   : Not Used
'ARM IO   : Add Path Points
SUB AddPathPointsARM_0x0D(address AS INTEGER, numofpaths AS INTEGER, patharray() AS INTEGER)

    LOCAL Cmd AS STRING
    LOCAL paths AS STRING
    LOCAL num AS INTEGER

    'make sure module is ARM IO
    IF Glo.ModuleType(address) <> ArmIoID THEN EXIT SUB  'Print "ERROR: Not ARM IO"

    FOR num = 1 TO numofpaths
        paths = paths + MKI$( patharray(num) )
    NEXT

    'build the command string
    Cmd = CHR$(&HAD) + paths

    ProcessCMD address, Cmd

END SUB


'0x0E COMMON NMC COMMAND  / Each module type has specific status response pre-loaded
'PIC SERVO: No Op           Returns Status of specfic data as set with "Define Status" , 0x02 command
'PIC IO   : SAME
'ARM IO   : SAME
SUB NoOp_0x0E (address AS INTEGER)

    LOCAL Cmd AS STRING

    Cmd = CHR$(&HE)  'nop

    ProcessCMD address, Cmd

END SUB


'********************************************************************************************************************
'                   Command Based Subs & Functions
'********************************************************************************************************************

'0x04 BASED PIC-SERVO SPECIFIC
'PIC SERVO: Load Trajectory
'PIC IO   : Set PWM
'ARM IO   : Not Used
SUB MoveVel (address AS INTEGER, MoveDir AS INTEGER, velocity AS LONG, accel AS LONG) 'modified to ignore ARM and PIC IO module

    LOCAL ControlByte AS INTEGER
    LOCAL Cmd AS STRING

    'make sure module is a Pic Servo
    IF Glo.ModuleType(address) <> PicServoID THEN EXIT SUB  'Print "ERROR: Not Servo"

    SetHomeCap 'stop on limit 1

    IF MoveDir = PosDir THEN
        ControlByte = LoadVel OR LoadAcc OR PosMode OR VelMode
    ELSE
        ControlByte = LoadVel OR LoadAcc OR PosMode OR VelMode OR RevDir
    END IF

    'build the command string
    Cmd = CHR$(&H94) + CHR$(ControlByte) + MKL$(velocity) + MKL$(accel)

    ProcessCMD address, Cmd

    GoMtrs

END SUB


'0x04 BASED PIC-SERVO SPECIFIC
'PIC SERVO: Load Trajectory
'PIC IO   : Set PWM
'ARM IO   : Not Used
SUB SetAccel (address AS INTEGER)

    LOCAL Cmd AS STRING

    'make sure module is a Pic Servo
    IF Glo.ModuleType(address) <> PicServoID THEN EXIT SUB  'Print "ERROR: Not Servo"

        Cmd = CHR$(&H54) + CHR$(LoadAcc) + MKL$(Glo.CmdAccel(address))

    ProcessCMD address, Cmd

END SUB


'0x05 BASED PIC-SERVO SPECIFIC
'PIC SERVO: Start Motion
'PIC IO   : Synch Output
'ARM IO   : Start Motion
SUB GoMtrs

    LOCAL Cmd AS STRING
    Cmd = CHR$(&H5)
    ProcessCmd AllServos, Cmd

END SUB


'0x06 BASED PIC-SERVO SPECIFIC
'PIC SERVO: Set Gain
'PIC IO   : Set Output
'ARM IO   : NOT USED
SUB SetGain (address AS INTEGER)  'modified to ignore ARM-IO and PIC-IO module

    LOCAL Cmd AS STRING

    'make sure module is a Pic Servo
    IF Glo.ModuleType(address) <> PicServoID THEN EXIT SUB  'Print "ERROR: Not Servo"


    'make sure current limit checking is turned off. When on, analog input determines
    'motor current limit. This input is being used to read a user pot control!
    Glo.CL(address) = 0 'turn off current limiting


    Cmd = CHR$(&HD6) + MKI$(Glo.Kp(address)) + MKI$(Glo.Kd(address))
    Cmd = Cmd + MKI$(Glo.Ki(address)) + MKI$(Glo.IL(address))
    Cmd = Cmd + CHR$(Glo.ol(address)) + CHR$(Glo.CL(address)  )
    Cmd = Cmd + MKI$(Glo.EL(address)) + CHR$(Glo.SRD(address))

    ProcessCMD address, Cmd

END SUB


'0x07 BASED PIC-SERVO SPECIFIC
'PIC SERVO: Stop Motor
'PIC IO   : Set Synch Output
'ARM IO   : Stop Motion
SUB EnableAmpl (address AS INTEGER, Value AS INTEGER) 'modified to ignore ARM-IO and PIC-IO module

    LOCAL Cmd AS STRING

    'make sure module is a Pic Servo
    IF Glo.ModuleType(address) <> PicServoID THEN EXIT SUB  'Print "ERROR: Not Servo"


    IF Value THEN
        Cmd = CHR$(&H17) + CHR$(EnableAmp)
        Glo.MiscMode(address) = Glo.MiscMode(address) OR AmpEnabled '= 0b00000001
    ELSE
        Cmd = CHR$(&H17) + CHR$(0)
        Glo.MiscMode(address) = (Glo.MiscMode(address) AND (NOT AmpEnabled))
    END IF

    ProcessCMD address, Cmd

END SUB


'0x07 BASED PIC-SERVO SPECIFIC
'PIC SERVO: Stop Motor
'PIC IO   : Set Synch Output
'ARM IO   : Stop Motion
SUB StopMtr (address AS INTEGER, StopMode AS INTEGER)

    LOCAL Cmd AS STRING

    'make sure module is a Pic Servo
    IF Glo.ModuleType(address) <> PicServoID THEN EXIT SUB  'Print "ERROR: Not Servo"

    Cmd = CHR$(&H17) + CHR$(StopMode)  '= 0b00000101
    ProcessCMD address, Cmd

    'set current PWM values to 0, matching PIC StopAbrupt
    IF address = AllServos THEN
        Glo.CmdPwm(1) = 0
        Glo.CmdPwm(2) = 0
        Glo.CmdPwm(3) = 0
    ELSE
        Glo.CmdPwm(address) = 0
    END IF

END SUB


'0x09 BASED PIC-SERVO SPECIFIC
'PIC SERVO: Set Homing
'PIC IO   : Not Used
'ARM IO   : Not Used
SUB SetHomeCap

    LOCAL address AS INTEGER
    LOCAL Cmd AS STRING

    'make sure module is a Pic Servo
    IF Glo.ModuleType(address) <> PicServoID THEN EXIT SUB  'Print "ERROR: Not Servo"

    address = &HFF   'all Mtrs

    Cmd = CHR$(&H19) + CHR$(&H11) 'was &H9 changed to &H11: stop abruptly on home

    ProcessCMD address, Cmd

END SUB


'0x0E BASED PIC-SERVO SPECIFIC
'PIC SERVO: No Op           Returns Status of specfic data as set with "Define Status" , 0x02 command
'PIC IO   : SAME
'ARM IO   : SAME
SUB GetStatus(address AS INTEGER)

    LOCAL Num AS INTEGER
    LOCAL Cmd AS STRING

    Cmd = CHR$(&HE)  'nop

    IF address = AllServos THEN  'load status all PIC-Servos
       FOR Num = 1 TO LastServo
           ProcessCMD Num, Cmd
        NEXT
    ELSE
       ProcessCMD address, Cmd
    END IF

END SUB



'****************************************************************************************
'                                   MISC
'****************************************************************************************
FUNCTION GetCoord (mCounts AS LONG, plus AS INTEGER) AS LONG

    IF plus = TRUE THEN     'positive direction
        GetCoord = mCounts
    ELSE
        GetCoord = -mCounts 'negative direction
    END IF

    EXIT FUNCTION

END FUNCTION


FUNCTION QStr (BYVAL Amount AS SINGLE, BYVAL Places AS INTEGER) AS STRING

    QStr = LEFT$(LTRIM$(STR$(Amount)) + SPACE$(Places), Places)

END FUNCTION


FUNCTION GoodLNG (Num AS STRING) AS INTEGER

    IF VAL(Num) > 2147483647 THEN
        GoodLNG = FALSE
        EXIT FUNCTION
    ELSEIF VAL(Num) < -2147483648# THEN
        GoodLNG = FALSE
        EXIT FUNCTION
    ELSE
        GoodLNG = TRUE
        EXIT FUNCTION
    END IF

END FUNCTION


FUNCTION GoodSNG (Num AS STRING) AS INTEGER

    IF VAL(Num) < -3.402823E+38 THEN
        GoodSNG = FALSE
        EXIT FUNCTION
    ELSEIF VAL(Num) > 3.402823E+38 THEN
        GoodSNG = FALSE
        EXIT FUNCTION
    ELSE
        GoodSNG = TRUE
        EXIT FUNCTION
    END IF

END FUNCTION


FUNCTION KeyDown AS INTEGER

    IF GRAPHIC(INSTAT) THEN
        KEYDOWN = -1
    ELSE
        KEYDOWN = 0
    END IF

END FUNCTION


SUB DelayX (Millisec AS INTEGER) '

    SLEEP Millisec

END SUB


FUNCTION DelayFact AS LONG

    'determine cts per milisec
    LOCAL T,x AS DOUBLE
    LOCAL CtrBegin AS LONG
    LOCAL CtrEnd, Ctr   AS LONG
    T = TIMER 'times in seconds

    DO
        CtrBegin = CtrEnd + 1: CtrEnd = CtrBegin + 100000
        FOR Ctr = CtrBegin TO CtrEnd: NEXT
        x = TIMER - T  'rollover at midnight, careful here!
    LOOP UNTIL x > .50# 'be > .5 seconds for accuracy and rollover

    DelayFact = Ctr / (x# * 1000)  'divide counter by 1000 (millisecs)

    EXIT FUNCTION

END FUNCTION


FUNCTION GetTick () AS LONG

'   GetTick& = GetTickCount

END FUNCTION




'***************************************************************************
'                     Calibration File I/O
'***************************************************************************

FUNCTION CalSave(filename AS STRING) AS INTEGER

    LOCAL ecode AS INTEGER
    LOCAL BytesRead AS INTEGER
    LOCAL filenumber AS INTEGER

    'FCreate (filenumber, 0, filename, ECode)
    IF NOT ECode THEN
       CalSave = FALSE
       EXIT FUNCTION
    END IF

    'DFWrite(filenum, BYVAL VARPTR(HdrVer), 0, BytesRead, ECode)
    IF NOT ECode THEN GOTO ExitCalSave
    'DFWrite2(filenum, BYVAL VARPTR(SCANstruc),LEN(HdrVer), BytesRead, ECode)
    IF NOT ECode THEN GOTO ExitCalSave

ExitCalSave:
    'FClose(filenum)
    IF NOT ECode THEN
      CalSave = FALSE
    ELSE
      CalSave = TRUE
    END IF

END FUNCTION



'''''''''''''''''''''''''''''''''''''''''''''
FUNCTION CalLoad(filename AS STRING) AS INTEGER

   LOCAL ecode AS INTEGER
   LOCAL BytesRead AS INTEGER
   LOCAL filenumber AS INTEGER
'   LOCAL temphdr AS HEADER

'  FOpen (filenum, 0,0, filename, ECode)
   IF NOT ECode THEN
     CalLoad = FALSE
     EXIT FUNCTION
   END IF

'  DFRead(filenum, BYVAL VARPTR(temphdr),0,BytesRead, ECode)

   IF NOT ECode THEN GOTO ExitCalLoad

   'Verify correct header
 '   IF HdrVer <> Temphdr THEN
'     ECode = TRUE
'     GOTO ExitCalLoad
'   END IF
'   DFRead2(filenum, BYVAL VARPTR (ScanStruc), LEN(temphdr), BytesRead, ECode)

   IF NOT ECode THEN GOTO ExitCalLoad

ExitCalLoad:

'  FClose(filenum)
   IF NOT ECode THEN
     CalLoad = FALSE
   ELSE
     CalLoad = TRUE
   END IF

END FUNCTION
'<<END>>

SUB EZ_Main(VerNum&)     ' (PROTECTED)
     EZ_Reg %EZ_CUSTID,%EZ_REGNUM
     EZ_DefImageFolder "Graphics"
     EZ_AllowCommandEvents  0
     EZ_DefFont 6, "Arial", 10, "V"
     EZ_DefFont 7, "Courier New", 10, "F"
     EZ_DefFont 8, "Times New Roman", 10, "V"
     EZ_DefFont 9, "Modern", 10, "V"
     EZ_DefSystemColor 32, 4
     EZ_DefSystemColor 33, 5
     EZ_DefSystemColor 34, 15
     EZ_DefSystemColor 35, 24
     EZ_DefColorL 36, &H00B96FFF
     EZ_DefColorL 37, &H0014AB9F
     EZ_DefColorL 38, &H0047A7FF
     EZ_DefColorL 39, &H00D2AACF
     EZ_DefColorL 40, &H001CD5E3
     EZ_DefColorL 41, &H00BC8943
     EZ_DefColorL 42, &H006C6AB7
     EZ_DefColorL 43, &H00DD4489
     IF Main_Initialize(VerNum&) THEN
          EZ_MAINFORM_Display ""
     END IF
END SUB

' -------------------------------------------------------------------------------------

SUB EZ_DesignWindow(FormName$)     ' (PROTECTED)
     SELECT CASE FormName$
          CASE "MAINFORM"
               EZ_MAINFORM_Design
          CASE ELSE
               OtherForm_Design FormName$
     END SELECT
END SUB

' -------------------------------------------------------------------------------------

SUB EZ_Events(FormName$, CID&, CMsg&, CVal&, Cancel&)     ' (PROTECTED)
     IF PreProcess_Events(FormName$, CID&, CMsg&, CVal&, Cancel&) THEN EXIT SUB
     SELECT CASE FormName$
          CASE "MAINFORM"
               EZ_MAINFORM_ParseEvents CID&, CMsg&, CVal&, Cancel&
          CASE ELSE
               OtherForm_Events FormName$, CID&, CMsg&, CVal&, Cancel&
     END SELECT
END SUB

' -------------------------------------------------------------------------------------





' *************************************************************************************
'                                Applications FORM Code
' *************************************************************************************


' ======================================
' [USER ACCESSABLE CODE]  You may Edit !
' ======================================


FUNCTION Main_Initialize(BYVAL VerNum&) AS LONG
    LOCAL RV&
    RV&=1
    FUNCTION=RV&
    DIM HdrVer AS STRING * 20
    DIM ThumbDisk AS STRING * 2

    'COM PORTS
    DIM  RecvSize AS LONG
    DIM  XmitSize AS LONG
    DIM  MemSize AS LONG
    DIM  MCUport AS STRING
    DIM  MCUbaud AS LONG

    'keypad table
    DIM KeyTable(20) AS STRING

    'delay timer
    DIM  DelayCtr AS LONG
    DIM  WaitX AS INTEGER


    'joystick to pwm conversion table
    DIM  LF(0 TO 255)
    DIM  LU(0 TO 255)
    DIM  Corr1(0 TO 255) AS BYTE
    DIM  Corr2(0 TO 255) AS BYTE

    'Vel & Accel pot tables
    DIM  XVel(255) AS LONG
    DIM  YVel(255) AS LONG
    DIM  XAcel(255) AS LONG
    DIM  YAcel(255) AS LONG

    'Speed Control tables
    DIM  XSpd(0 TO 255)
    DIM  YSpd(0 TO 255)


    DIM  CalSet AS INTEGER
    DIM lResult AS LONG

    '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! IMPORTANT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    'MUST BE SET FOR EACH INSTALLED  MODULE/S:

    'Settings for installed Hardware: Specific to this particular motor controller

    'REQUIRED: Total Number of NMC modules in this system
     Hardware.SystemModules = 6

    'REQUIRED: Set to each module type, in order of address location.
    '          use pre-defined CONST above, up to 32 modules supported
     Hardware.SystemModuleType(1) = PicServoID
     Hardware.SystemModuleType(2) = PicServoID
     Hardware.SystemModuleType(3) = PicServoID
     Hardware.SystemModuleType(4) = PicServoID
     Hardware.SystemModuleType(5) = PicIoID
     Hardware.SystemModuleType(6) = ArmIoID

    'Optional:
    'Hardware.SystemModuleVer(x) = 'Version number of each individual module
    'Hardware.SystemVersion =      'MCU Version, Max 20 string characters
    'Hardware.SystemName =         'Name of Motor Controller Unit (MCU), Max 20 string characters
    'Hardware.SystemSN =           'Serial Number of MCU,  Max 20 string characters
    'Hardware.SystemDate =         'Date of manufacture,   Max 6 string characters

    '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! IMPORTANT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


    MCUport ="COM6"
    MCUbaud = 115200
    McuPortNum = FREEFILE


    DelayCtr = DelayFact
    WaitX = 1
    'joystick to pwm conversion table
    'SetTables

    'new keypad layout

    '***********************************************
    'Open & Check Com Buffers, Report & Fix errors
    '
    '  - check PIC, power on, etc..
    '***********************************************
    '    IsSplashActive = 1
    '   ShowSplashDlg(1000, "atcosplash.bmp", 1, "MCU 2015",1)
    IF NOT OpenComPort THEN
       'MSGBOX "ERROR, POWER OFF/ON",, "OpenComPorts serial connection failed."
       DO
          EXIT FUNCTION
       LOOP
    END IF





'    IF NOT InitNetWork THEN
'       lResult& = MSGBOX("SETUP ERROR", %MB_OKCANCEL OR %MB_DEFBUTTON2 OR %MB_TASKMODAL, "InitNetWork Failed.")
'        DO
'           DelayX(200)
'           IF lResult& = %IDCANCEL THEN
'               EXIT FUNCTION
'           END IF
'        LOOP UNTIL InitNetWork
'    END IF

    DIM GloErr AS INTEGER

'    CalSet = FALSE
    '    IF NOT KeyDown THEN  'do not load if user has key pressed
    '      IF CalLoad(ThumbDisk + "0.M2K") THEN
    '       CalSet = TRUE
    '     END IF
    '    END IF

    'if no cal on disk or corrupt then set defaults
'    IF NOT CalSet THEN
'       SetDefaults
'    END IF
'    Scanstruc.NextFlag = FALSE 'incase cal was saved during scan
'    SetForAuto  'set velocity, etc. & motors on
'    DelayX(200)
'    BUILDWINDOW()
'    DIALOG SHOW MODAL hDlg, CALL DlgProc
    '  UnhookWindowsHookEx ghMsgHook








'IO TEST CODE END

'\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
'/////
END FUNCTION

SUB OtherForm_Design(FormName$)
     SELECT CASE FormName$
          CASE ELSE
     END SELECT
END SUB

SUB OtherForm_Events(FormName$, CID&, CMsg&, CVal&, Cancel&)
     SELECT CASE FormName$
          CASE "{OPENDLG}", "{SAVEDLG}", "{OPENDLGX}", "{SAVEDLGX}", "{COLORDLG}", "{FONTDLG}", "{PRINTDLG}", "{PAGEDLG}", "{FINDDLG}"
          CASE "{ABORTDLG}"
          CASE "{MSGBOX}"
          CASE "{APP}"      ' Not a Form
               SELECT CASE CMsg&
                    CASE %EZ_NoTheme
                    CASE %EZ_Terminate
               END SELECT
          CASE ELSE
     END SELECT
END SUB

FUNCTION PreProcess_Events(FormName$, CID&, CMsg&, CVal&, Cancel&) AS LONG
     LOCAL RV&
     RV&=0
     FUNCTION=RV&
END FUNCTION


'<<BEGINFORM>> "MAINFORM"


' ======================================
' [PROTECTED CODE]         Do NOT Edit !
' ======================================

SUB EZ_MAINFORM_Display(BYVAL FParent$)     ' (PROTECTED)
     LOCAL hMainMenu&
     ' Main Menu handle automatically stored by EZGUI
     hMainMenu&=EZ_DefMainMenu( %MAINFORM_FILEMENU, "&File", "")
     EZ_Color -1, -1
     EZ_AllowLoadingEvent 2
     EZ_Form "MAINFORM", FParent$, "ATCO NDT", 0, 0, 200, 65, "^_CZ"
END SUB

SUB EZ_MAINFORM_Design()     ' (PROTECTED)
     LOCAL CText$
     LOCAL hMainMenu&, hDropMenu&, hSubMenu&
     hMainMenu&=EZ_GetMenu("MAINFORM", 0)
     EZ_AddMenuItem hMainMenu&, %MAINFORM_SETUPMENU, 0, "&Setup", ""
     EZ_AddMenuItem hMainMenu&, %MAINFORM_WINDOWITEM, 0, "&Window", ""
     ' ------------------------------------------------

     EZ_Color-1,-1
     EZ_UseIFont "Times New Roman", 14,"BV"
     EZ_Label %MAINFORM_XLABEL, 2, 2.5, 5, 2, "X", "C"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseIFont "Times New Roman", 14,"BV"
     EZ_Label %MAINFORM_XLABEL1, 2, 8.3125, 5, 1.625, "R", "C"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseIFont "Times New Roman", 14,"BV"
     EZ_Label %MAINFORM_XLABEL2, 2.125, 5.3125, 5, 1.6875, "Y", "C"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Text %MAINFORM_RPOS, 8.875, 7.875, 31.875, 2.4375, "", "EST"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Text %MAINFORM_YPOS, 9, 4.9375, 31.875, 2.4375, "", "EST"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Text %MAINFORM_XPOS, 9, 2, 31.875, 2.4375, "", "EST"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_SETXPOS, 43.625, 2.25, 10, 2, "Set X Pos", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_SETYPOS, 43.625, 5.125, 10, 2, "Set Y Pos", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_SETRPOS, 43.625, 8.125, 10, 2, "Set R Pos", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_AllowLoadingEvent 2
     EZ_CheckBox %MAINFORM_XMOTORON, 62, 2.25, 5, 2, "On", "AT"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_AllowLoadingEvent 2
     EZ_CheckBox %MAINFORM_YMOTORON, 61.875, 5, 5, 2, "On", "AT"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_AllowLoadingEvent 2
     EZ_UseAutoSize "VH"
     EZ_CheckBox %MAINFORM_RMOTORON, 62, 8.25, 5, 2, "On", "AT"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_Label %MAINFORM_LABEL1, 54.625, 2.625, 6, 1, "X Motor", "C"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_Label %MAINFORM_LABEL2, 54.625, 5.5625, 6, 1, "Y Motor", "C"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_Label %MAINFORM_LABEL3, 54.625, 8.75, 6, 1, "R Motor", "C"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_HTrackBar %MAINFORM_HTRACKBAR1, 101.125, 31, 31.625, 1, "=T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Label %MAINFORM_LABEL4, 108.25, 29.1875, 12, 1, "Jog Rate", "C"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Text %MAINFORM_JOGRATE, 134.375, 30.3125, 8.625, 2.375, "", "EST"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Label %MAINFORM_LABEL5, 96.5, 30.8125, 3, 1, "0", "C"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_BUTTON4, 186, 4.5625, 6, 2, "", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_BUTTON5, 186, 2.5625, 6, 2, "", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_BUTTON6, 186, 6.5625, 6, 2, "", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_BUTTON7, 186, 8.5625, 6, 2, "", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_BUTTON8, 172, 2.5625, 6, 2, "", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_BUTTON9, 172, 4.5625, 6, 2, "", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_BUTTON10, 172, 6.5625, 6, 2, "", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_BUTTON11, 186, 12.5625, 6, 2, "", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_BUTTON12, 186, 10.5625, 6, 2, "", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_BUTTON13, 172, 8.5625, 6, 2, "", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_BUTTON14, 172, 10.5625, 6, 2, "", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_BUTTON15, 172, 12.5625, 6, 2, "", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_BUTTON16, 179, 2.5625, 6, 2, "", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_BUTTON17, 179, 4.5625, 6, 2, "", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_BUTTON18, 179, 6.5625, 6, 2, "", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_BUTTON19, 179, 8.5625, 6, 2, "", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_BUTTON20, 179, 10.5625, 6, 2, "", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_BUTTON21, 179, 12.5625, 6, 2, "", "T"
     ' -----------------------------------------------
     EZ_Color 15, 0
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Text %MAINFORM_LOG, 0, 37, 200, 28, "", "EST"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Radio %MAINFORM_POLAR, 3, 15.5, 10, 1.0625, "Polar", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Radio %MAINFORM_CARTESIAN, 15, 15.75, 10, 1, "Cartesian", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Label %MAINFORM_LABEL6, 3, 13.625, 19, 1, "Coordinate System", "C"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_Label %MAINFORM_LABEL7, 116, 2, 8, 1, "Jog Control", "C"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_YPLUS, 74.5, 3, 3, 2, "Y+", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_XMINUS, 71.125, 5.375, 3, 2, "X-", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_XPLUS, 77.5, 5.4375, 3, 2, "X+", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_YMINUS, 74.5, 7.8125, 3, 2, "Y-", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Radio %MAINFORM_CONTINUOUS, 104.75, 33, 10, 1, "Continuous", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Radio %MAINFORM_STEP, 119.875, 33, 10, 1, "Step", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_SETALL, 30, 13.625, 8, 2, "Set All", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_ALLOFF, 40.25, 13.625, 8, 2, "All Off", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_AllowLoadingEvent 2
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_ALLON, 51, 13.625, 8, 2, "All On", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_GOAUTOSCAN, 3, 18.625, 14, 2, "Go: Auto Scan", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_BLANK, 25, 18.625, 14, 2, "", "T"
     ' -----------------------------------------------
     EZ_Color 0, 12
     EZ_UseIFont "System", 10,"BV"
     EZ_UseAutoSize "VH"
     EZ_ODButton %MAINFORM_STOPSCAN, 47, 18.625, 14, 2, "Stop: Scan", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Canvas %MAINFORM_JOGCANVAS, 83.5, 4, 74.5, 25, ""
     MAINFORM_JOGCANVAS_Draw -1
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_RPLUS, 160, 3, 4, 2, "R+", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Button %MAINFORM_RMINUS, 159.875, 7, 4, 2, "R-", "T"
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Frame %MAINFORM_FRAME1, 0, 1, 69, 11, "", ""
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Frame %MAINFORM_FRAME2, 70, 1, 96.875, 34.5, "", ""
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Frame %MAINFORM_FRAME3, 169.875, .9375, 24, 15, "", ""
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "VH"
     EZ_Frame %MAINFORM_FRAME4, 1, 12.625, 25, 5, "", ""
     ' -----------------------------------------------
     EZ_Color-1,-1
     EZ_UseFont 4
     EZ_UseAutoSize "CT"
     EZ_Frame %MAINFORM_FRAME5, 83.5, 3, 19, 8, "Frame  5", ""
     ' -----------------------------------------------
END SUB


' ======================================
' [USER ACCESSABLE CODE]  You may Edit !
' ======================================

SUB MAINFORM_MenuEvents(BYVAL MyID&, CMsg&, CVal&, Cancel&, BYVAL hMenu&, BYVAL MenuText$)
     SELECT CASE MyID&
          CASE %MAINFORM_FILEMENU
               SELECT CASE CMsg&
                    CASE %EZ_Click
                    CASE %EZ_Selected
               END SELECT
          CASE %MAINFORM_SETUPMENU
               SELECT CASE CMsg&
                    CASE %EZ_Click
                    CASE %EZ_Selected
               END SELECT
          CASE %MAINFORM_WINDOWITEM
               SELECT CASE CMsg&
                    CASE %EZ_Click
                    CASE %EZ_Selected
               END SELECT
          CASE ELSE
     END SELECT
END SUB


' ======================================
' [PROTECTED CODE]         Do NOT Edit !
' ======================================


SUB EZ_MAINFORM_ParseEvents(CID&, CMsg&, CVal&, Cancel&)     ' (PROTECTED)
     SELECT CASE CID&
          CASE %EZ_Window
               MAINFORM_Events CID&, CMsg&, CVal&, Cancel&
          CASE %MAINFORM_FILEMENU
               MAINFORM_MenuEvents CID&, CMsg&, CVal&, Cancel&, EZ_GetMenu("MAINFORM", 0), "&File"
          CASE %MAINFORM_SETUPMENU
               MAINFORM_MenuEvents CID&, CMsg&, CVal&, Cancel&, EZ_GetMenu("MAINFORM", 0), "&Setup"
          CASE %MAINFORM_WINDOWITEM
               MAINFORM_MenuEvents CID&, CMsg&, CVal&, Cancel&, EZ_GetMenu("MAINFORM", 0), "&Window"
          CASE  %MAINFORM_RPOS
               MAINFORM_RPOS_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_YPOS
               MAINFORM_YPOS_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_XPOS
               MAINFORM_XPOS_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_SETXPOS
               MAINFORM_SETXPOS_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_SETYPOS
               MAINFORM_SETYPOS_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_SETRPOS
               MAINFORM_SETRPOS_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_XMOTORON
               MAINFORM_XMOTORON_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_YMOTORON
               MAINFORM_YMOTORON_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_RMOTORON
               MAINFORM_RMOTORON_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_HTRACKBAR1
               MAINFORM_HTRACKBAR1_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_JOGRATE
               MAINFORM_JOGRATE_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_BUTTON4
               MAINFORM_BUTTON4_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_BUTTON5
               MAINFORM_BUTTON5_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_BUTTON6
               MAINFORM_BUTTON6_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_BUTTON7
               MAINFORM_BUTTON7_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_BUTTON8
               MAINFORM_BUTTON8_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_BUTTON9
               MAINFORM_BUTTON9_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_BUTTON10
               MAINFORM_BUTTON10_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_BUTTON11
               MAINFORM_BUTTON11_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_BUTTON12
               MAINFORM_BUTTON12_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_BUTTON13
               MAINFORM_BUTTON13_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_BUTTON14
               MAINFORM_BUTTON14_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_BUTTON15
               MAINFORM_BUTTON15_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_BUTTON16
               MAINFORM_BUTTON16_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_BUTTON17
               MAINFORM_BUTTON17_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_BUTTON18
               MAINFORM_BUTTON18_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_BUTTON19
               MAINFORM_BUTTON19_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_BUTTON20
               MAINFORM_BUTTON20_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_BUTTON21
               MAINFORM_BUTTON21_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_LOG
               MAINFORM_LOG_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_YPLUS
               MAINFORM_YPLUS_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_XMINUS
               MAINFORM_XMINUS_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_XPLUS
               MAINFORM_XPLUS_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_YMINUS
               MAINFORM_YMINUS_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_SETALL
               MAINFORM_SETALL_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_ALLOFF
               MAINFORM_ALLOFF_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_ALLON
               MAINFORM_ALLON_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_GOAUTOSCAN
               MAINFORM_GOAUTOSCAN_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_BLANK
               MAINFORM_BLANK_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_STOPSCAN
               MAINFORM_STOPSCAN_Events CID&, CMsg&, CVal&, Cancel&
               IF CMsg&=%EZ_OwnerDraw THEN
                    EZ_Draw3DButton "MAINFORM", %MAINFORM_STOPSCAN, CVal&, 12, 0,  EZ_ODIFont
               END IF
          CASE  %MAINFORM_RPLUS
               MAINFORM_RPLUS_Events CID&, CMsg&, CVal&, Cancel&
          CASE  %MAINFORM_RMINUS
               MAINFORM_RMINUS_Events CID&, CMsg&, CVal&, Cancel&
          CASE ELSE
               MAINFORM_Events CID&, CMsg&, CVal&, Cancel&
     END SELECT
END SUB

' ======================================
' [USER ACCESSABLE CODE]  You may Edit !
' ======================================

SUB MAINFORM_Events(CID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CID&
          CASE %EZ_Window
               SELECT CASE CMsg&
                    CASE %EZ_Loading
                    CASE %EZ_Loaded
                    CASE %EZ_Started
                    CASE %EZ_Close
                    CASE ELSE
               END SELECT
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_RPOS_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Change
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_YPOS_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Change
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_XPOS_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Change
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_SETXPOS_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_SETYPOS_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_SETRPOS_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_XMOTORON_Events( MyID&, CMsg&, CVal&, Cancel&)
    STATIC buttonon AS INTEGER
     SELECT CASE CMsg&
          CASE %EZ_Loaded
                EZ_SetColor "MAINFORM", MyID&, 1,12
                EZ_SetText "MAINFORM", MyID&, "Off"
                buttonon = 0
          CASE %EZ_Click
               IF buttonon = 1 THEN
                EZ_SetColor "MAINFORM", MyID&, 1,12
                EZ_SetText "MAINFORM", MyID&, "Off"
                buttonon = 0
               ELSE
                buttonon = 1
                EZ_SetColor "MAINFORM", MyID&, 1, 10
                EZ_SetText "MAINFORM", MyID&, "On
               END IF
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_YMOTORON_Events( MyID&, CMsg&, CVal&, Cancel&)
     STATIC buttonon AS INTEGER
     SELECT CASE CMsg&
         CASE %EZ_Loaded
                EZ_SetColor "MAINFORM", MyID&, 1,12
                EZ_SetText "MAINFORM", MyID&, "Off"
                buttonon = 0
          CASE %EZ_Click
               IF buttonon = 1 THEN
                EZ_SetColor "MAINFORM", MyID&, 1,12
                EZ_SetText "MAINFORM", MyID&, "Off"
                buttonon = 0
               ELSE
                buttonon = 1
                EZ_SetColor "MAINFORM", MyID&, 1, 10
                EZ_SetText "MAINFORM", MyID&, "On
               END IF
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_RMOTORON_Events( MyID&, CMsg&, CVal&, Cancel&)
     STATIC buttonon AS INTEGER
     SELECT CASE CMsg&
          CASE %EZ_Loaded
                EZ_SetColor "MAINFORM", MyID&, 1,12
                EZ_SetText "MAINFORM", MyID&, "Off"
                buttonon = 0
          CASE %EZ_Click
               IF buttonon = 1 THEN
                EZ_SetColor "MAINFORM", MyID&, 1,12
                EZ_SetText "MAINFORM", MyID&, "Off"
                buttonon = 0
               ELSE
                buttonon = 1
                EZ_SetColor "MAINFORM", MyID&, 1, 10
                EZ_SetText "MAINFORM", MyID&, "On
               END IF
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_HTRACKBAR1_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Change
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_JOGRATE_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Change
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_BUTTON4_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_BUTTON5_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_BUTTON6_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_BUTTON7_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_BUTTON8_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_BUTTON9_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_BUTTON10_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_BUTTON11_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_BUTTON12_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_BUTTON13_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_BUTTON14_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_BUTTON15_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_BUTTON16_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_BUTTON17_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_BUTTON18_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_BUTTON19_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_BUTTON20_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_BUTTON21_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_LOG_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Change
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_YPLUS_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_XMINUS_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_XPLUS_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_YMINUS_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_SETALL_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_ALLOFF_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_ALLON_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_GOAUTOSCAN_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_BLANK_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_STOPSCAN_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          CASE %EZ_Click
          CASE ELSE
     END SELECT
END SUB



SUB MAINFORM_JOGCANVAS_Draw(BYVAL FMode&)
    LOCAL CW&, CH&, PW&
    'LOCAL X1&,Y1&, DX&, DY&, X2&, Y2&
    LOCAL p AS STRING
    LOCAL ShapeInfo AS STRING
    x1 = 200
    x2 = 200
    y1 = 8
    y2 = 392
    inc = 0.0
    EZ_GetCanvasSize "MAINFORM", %MAINFORM_JOGCANVAS, CW&, CH&
    EZ_StartDraw "MAINFORM", %MAINFORM_JOGCANVAS, CW&, Ch&, "V"
          P$ = EZ_LoadPicture(EZ_AppPath+"wheel.bmp")
          EZ_CDrawPicture 0, 0, 400,400, P$, ""
          EZ_FreeImage P$
          EZ_ColorRGB RGB(255,0,0), RGB(255,0,0)
          EZ_CDraw %EZ_LINE, x1,y1,x2,y2, 3, 1
          EZ_DefPoly  "(0,0)(1,1)(1,0)(0,0)"
          EZ_ColorRGB RGB(255,0,0), RGB(255,0,0)
          EZ_CDraw %EZ_ELLIPSE, x1-8,y1, x1+8, y1+8 ,1, 1

    EZ_EndDraw
END SUB

SUB MAINFORM_RPLUS_Events( MyID&, CMsg&, CVal&, Cancel&)
     SELECT CASE CMsg&
          LOCAL CW&, CH&, PW&
          LOCAL p AS STRING
          LOCAL ShapeInfo AS STRING
          LOCAL distance AS INTEGER
          LOCAL angle, Pi AS DOUBLE
          LOCAL radius AS INTEGER
          LOCAL slice AS DOUBLE
          LOCAL centerX, centerY AS INTEGER
          CASE %EZ_Click
             radius = 192
             inc = inc - 1
             Pi = 4 * ATN(1)
             centerx = 199
             centery = 199
             slice = 2 * (pi/100)
             angle = slice*inc
             x1 = SIN(angle) * radius + CenterX
             y1 = COS(angle) * radius + CenterY
             x2 = -SIN(angle) * radius + CenterX
             y2 = -COS(angle) * radius + CenterY
            EZ_GetCanvasSize "MAINFORM", %MAINFORM_JOGCANVAS, CW&, CH&
            EZ_StartDraw "MAINFORM", %MAINFORM_JOGCANVAS, CW&, Ch&, "V"
                P$ = EZ_LoadPicture(EZ_AppPath+"wheel.bmp")
                EZ_CDrawPicture 0, 0, 400,400, P$, ""
                EZ_FreeImage P$
                EZ_ColorRGB RGB(255,0,0), RGB(255,0,0)
                EZ_CDraw %EZ_LINE, x1,y1,x2,y2, 3, 1
                EZ_ColorRGB RGB(255,0,0), RGB(255,0,0)
                EZ_CDraw %EZ_ELLIPSE, x2-8,y2, x2+8, y2+8 ,1, 1
            EZ_EndDraw
          CASE ELSE
     END SELECT
END SUB

SUB MAINFORM_RMINUS_Events( MyID&, CMsg&, CVal&, Cancel&)
      SELECT CASE CMsg&
          LOCAL CW&, CH&, PW&
          LOCAL p AS STRING
          LOCAL ShapeInfo AS STRING
          LOCAL distance AS INTEGER
          LOCAL angle, Pi AS DOUBLE
          LOCAL radius AS INTEGER
          LOCAL slice AS DOUBLE
          LOCAL centerX, centerY AS INTEGER
          CASE %EZ_Click
             radius = 192
             inc = inc + 1
             Pi = 4 * ATN(1)
             centerx = 199
             centery = 199
             slice = 2 * (pi/100)
             angle = slice * inc
             x1 = SIN(angle) * radius + CenterX
             y1 = COS(angle) * radius + CenterY
             x2 = -SIN(angle) * radius + CenterX
             y2 = -COS(angle) * radius + CenterY

            EZ_GetCanvasSize "MAINFORM", %MAINFORM_JOGCANVAS, CW&, CH&
            EZ_StartDraw "MAINFORM", %MAINFORM_JOGCANVAS, CW&, Ch&, "V"
                P$ = EZ_LoadPicture(EZ_AppPath+"wheel.bmp")
                EZ_CDrawPicture 0, 0, 400,400, P$, ""
                EZ_FreeImage P$
                EZ_ColorRGB RGB(255,0,0), RGB(255,0,0)
                EZ_CDraw %EZ_LINE, x1,y1,x2,y2, 3, 1
                EZ_ColorRGB RGB(255,0,0), RGB(255,0,0)
                EZ_CDraw %EZ_ELLIPSE, x2-8,y2, x2+8, y2+8 ,1, 1
            EZ_EndDraw
          CASE ELSE
     END SELECT
END SUB



'<<END ALL FORMS>>    UnKnown Routines follow:
#IF %EZ_NOSKIPCODE
#ENDIF 'PARSE END
